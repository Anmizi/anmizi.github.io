<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>物理层通信基础</title>
    <link href="/posts/a4e28fd4.html"/>
    <url>/posts/a4e28fd4.html</url>
    
    <content type="html"><![CDATA[<h2 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h2><ul><li>信源：将消息转换为信号的设备，如计算机等</li><li>发送设备：将信源产生的信号进行适当的变换的装置，使之适合于总信道中进行传输。主要包括编码和调制</li><li>信道：信号传输通道，如物理介质</li><li>噪声：自然界和通信设备中所产生的干扰</li><li>接收设备：完成发送设备反变换，还原原始发送信号</li><li>信宿：信号终点，将信号转换为供人们能识别的消息</li></ul><p><img src="http://mark-imges.test.upcdn.net/images/image-20211001190247826.png" alt="image-20211001190247826"></p><h3 id="常见数据通信术语"><a href="#常见数据通信术语" class="headerlink" title="常见数据通信术语"></a>常见数据通信术语</h3><p>数据(data):    传送消息的实体</p><p>信号(signal):    数据的电气或电磁表示</p><p>模拟的(analogous):    参数的取值是连续的</p><p>数字的(digital):    参数的取值是离散的</p><p>码元(code):    信号的基本波形(信号基本单元)</p><p>频带(Spectrum):    信号频率范围</p><p>带宽(Bandwidth):    有效带宽</p><p>数据通信方式：单工，半双工，全双工</p><p>并行通信(同时多条线路) vs 串行通信(一次一位bit)</p><h3 id="信源编码"><a href="#信源编码" class="headerlink" title="信源编码"></a>信源编码</h3><p>Q:    如果信源产生的是模拟数据，如何在数字通信系统中传输</p><p>A:    信源编码</p><p>典型的信源编码：PCM</p><p>PCM包括三个步骤：采样    量化    编码</p><p>采样：用一系列中时间上离散的采样值，代替时间上连续的模拟数据，即实现时间上的离散化</p><p>量化：使采样值中取值上离散化</p><p>编码：将量化后的采样值用一定位数的二进制数码来表示</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20211001192751946.png" alt="image-20211001192751946"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络物理层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不会变量,别说你会JS</title>
    <link href="/posts/89576728.html"/>
    <url>/posts/89576728.html</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>typeof 能判断哪些类型</li><li>何时使用<code>===</code>何时使用<code>==</code></li><li>值类型和引用类型的区别</li><li>手写深拷贝</li></ul><p>值类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//值类型</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> b = a<br>a = <span class="hljs-number">200</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/image-20210913144917327.png" alt="image-20210913144917327"></p><p>引用类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引用类型</span><br><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;<br><span class="hljs-keyword">let</span> b = a<br>b.<span class="hljs-property">age</span> = <span class="hljs-number">21</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">age</span>) <span class="hljs-comment">//21</span><br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/image-20210913144937327.png" alt="image-20210913144937327"></p><h3 id="常见值类型"><a href="#常见值类型" class="headerlink" title="常见值类型"></a>常见值类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">100</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">true</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;s&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="常见引用类型"><a href="#常见引用类型" class="headerlink" title="常见引用类型"></a>常见引用类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<br><span class="hljs-keyword">const</span> arr = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;<br><span class="hljs-keyword">const</span> n = <span class="hljs-literal">null</span><br><span class="hljs-comment">//特殊引用类型，不存储数据，所以没有拷贝，复制函数这一说法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><ul><li>识别所有有值类型</li><li>识别函数</li><li>判断是否是引用类型（不可细分）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断所有值类型</span><br><span class="hljs-keyword">let</span> a<br><span class="hljs-keyword">typeof</span> a <span class="hljs-comment">//&#x27;undefined&#x27;</span><br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">typeof</span> str <span class="hljs-comment">//&#x27;string&#x27;</span><br><span class="hljs-keyword">const</span> n = <span class="hljs-number">100</span><br><span class="hljs-keyword">typeof</span> n <span class="hljs-comment">//&#x27;number&#x27;</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-literal">true</span><br><span class="hljs-keyword">typeof</span> b <span class="hljs-comment">//&#x27;boolean&#x27;</span><br><span class="hljs-keyword">const</span> s = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;s&#x27;</span>)<br><span class="hljs-keyword">typeof</span> s <span class="hljs-comment">//&#x27;symbol&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断函数</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> <span class="hljs-comment">//&#x27;function&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-comment">// &#x27;function&#x27;</span><br><span class="hljs-comment">//能识别引用类型（不能再继续识别）</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>] <span class="hljs-comment">//&#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125; <span class="hljs-comment">//&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝代码"><a href="#深拷贝代码" class="headerlink" title="深拷贝代码"></a>深拷贝代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj = &#123;&#125;</span>)&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> obj == <span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>  <span class="hljs-keyword">let</span> result<br>  <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)&#123;<br>    result = []<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    result = &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>    <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))&#123;<br>      result[key] = <span class="hljs-title function_">deepClone</span>(obj[key])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>字符串拼接</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">100</span> + <span class="hljs-number">10</span> <span class="hljs-comment">// 110</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-comment">//&#x27;10010&#x27;</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;10&#x27;</span> <span class="hljs-comment">//&#x27;true10&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>==</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">100</span> == <span class="hljs-string">&#x27;100&#x27;</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-number">0</span> == <span class="hljs-literal">false</span><br><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span><br><span class="hljs-comment">//上述都返回true</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//除了 == null之外，其他都一律使用 ===</span><br><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<br><span class="hljs-keyword">if</span>(obj.<span class="hljs-property">a</span> == <span class="hljs-literal">null</span>)&#123;&#125;<br><span class="hljs-comment">//相当于：</span><br><span class="hljs-comment">// if(obj.a === null || obj.a === undefined)</span><br></code></pre></td></tr></table></figure><ul><li>if语句和逻辑运算<ul><li>truly变量：!!a === true的变量</li><li>false变量：!!a === false的变量</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//以下是falsey变量，除此之外都是truely变量</span><br>!!<span class="hljs-number">0</span> === <span class="hljs-literal">false</span><br>!!<span class="hljs-string">&#x27;&#x27;</span> === <span class="hljs-literal">false</span><br>!!<span class="hljs-title class_">NaN</span> === <span class="hljs-literal">false</span><br>!!<span class="hljs-literal">null</span> === <span class="hljs-literal">false</span><br>!!<span class="hljs-literal">undefined</span> === <span class="hljs-literal">false</span><br>!!<span class="hljs-literal">false</span> === <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><font color=red>if语句判断的就是truely变量和falsely变量</font></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>值类型 vs 引用类型，堆栈模型，深拷贝</li><li>typeof运算符</li><li>类型转换，truly 和falsely变量</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概述</title>
    <link href="/posts/2ba40472.html"/>
    <url>/posts/2ba40472.html</url>
    
    <content type="html"><![CDATA[<h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><p>Simple Batch Systems</p><ul><li>Monitors(监督程序)：Software that controls the running programs<ul><li>Resident monitor is in main memory and available for execution</li></ul></li><li>Batch jobs together</li><li>Program branches back to monitor when finished</li><li>Processor must wait for I/O instruction to complete before proceeding</li><li>Be inefficient</li></ul><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><p>一个支持多道程序设计的系统允许多道程序同时准备运行，当正在运行那道程序由于某种原因(比如等待输入或输出数据)，暂时不能运行时,系统将自动地启动另一道程序进行运行，一旦原因消除(比如数据已经到达或已经传输完毕)，暂时运行的那道程序在将来的某个时间还是可以被系统重新调用运行。</p><h4 id="多道程序带来的问题"><a href="#多道程序带来的问题" class="headerlink" title="多道程序带来的问题"></a>多道程序带来的问题</h4><ul><li>Improper synchronization（同步）<ul><li>ensure a process waiting for an I/O device receives the singnal</li><li>保证等待IO设备的进程可以收到信号</li></ul></li><li>Failed mutual exclusion (互斥)</li><li>Nondeterminate program operation<ul><li>program should only depend on input to it</li></ul></li><li>Deadlocks (死锁)</li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>Time sharing</p><p>按时间分配，分配一个时间片，适用于交互式系统</p><p>带来的问题：中断频繁，导致时间开销大</p><ul><li>Using multiprogramming to handle multiple interactive jobs</li><li>Processor’s time is shared among multiple users</li><li>Multiple users simultanceously(同时) access the system throught terminals</li></ul><p>Batch Multiprogramming vs Time sharing</p><p>多道批处理系统与分时系统比较</p><table><thead><tr><th></th><th>Batch Mutiprogramming</th><th>Time sharing</th></tr></thead><tbody><tr><td>Principal objective</td><td>Maximize processor use</td><td>Minimize response time</td></tr><tr><td>Source of directive to operating system</td><td>Job control language commands provided width the job</td><td>Commands entered at the termianls</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统引论</title>
    <link href="/posts/f9a25cd7.html"/>
    <url>/posts/f9a25cd7.html</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ol><li>方便性</li><li>有效性</li><li>可扩展性</li><li>开发性</li></ol><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><p>操作系统在计算机系统中的作用，可以从<strong>用户</strong>，<strong>资源管理</strong>，<strong>资源抽象</strong>等多个不同的角度来分析和讨论</p><ul><li><p>用户角度：</p><p>OS处于计算机硬件系统和用户之间，用户通过OS来使用计算机系统。在OS的帮助下，用户可以方便，快捷的使用计算机运行自己的软件。</p></li><li><p>资源管理角度</p><p>OS可以对计算机系统的硬件和软件资源进行有效的管理。归纳起来可以将这些资源分为四类：处理机，存储器，IO设备以及文件(数据和程序)。</p></li><li><p>资源抽象角度</p><p>对于一台裸机(完全无软件的计算机系统)，它对用户提供的仅仅是硬件接口。除非用户对物理接口有充分的理解，否则难以使用。为了方便人们使用IO设备，人们在裸机上覆盖上一层 I/O 设备<br>管理软件，如图 1-2 所示，由它来实现对 I/O 设备操作的细节，并向上提供一组 I/O 操作命令，如 Read 和 Write 命令，用户可利用它来进行数据输入或输出，而无需关心 I/O 是如何实现的</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210909215714104.png" alt="image-20210909215714104"></p></li></ul><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>正是系统程序并发执行的特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量</p><ol><li>并行和并发</li></ol><p>并行性是指两个或多个事件在同一时刻发生。而并非性是指两个或多个程序在同一时间间隔内发生。</p><p>并发性是指在一段时间内<strong>宏观上有多个程序在同时运行</strong>，但是在单处理机中，每一时刻却仅能有一道程序运行，故<strong>微观上这些程序是交替进行的</strong>。</p><ol start="2"><li>进程</li></ol><p>进程，是指在系统中能独立运行并作为<strong>资源分配的基本单位</strong>，它是一组机器指令，数据和堆栈组成的，是一个可<strong>独立运行的活动实体</strong>。</p><p>多个进程间可以并发执行和交换信息。</p><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>操作系统下的共享和一般情况下的共享含义并不完全相同。一般情况下的共享是指某种资源能被大家使用，并未限定时间和空间。如图书馆中的书可供大家借阅，但大家并不需要同时且在同一地点阅读。</p><p>而在操作系统环境下的共享或称为<strong>资源复用</strong>，是指系统中的资源可供内存中的<strong>多个并发执行的进程共同使用</strong>。这里宏观上限定了时间和地点(内存)。</p><p>由于这种资源共享方式，导致进程间对资源的争夺，所以系统必须对资源共享进程妥善管理。</p><h4 id="资源共享的方式"><a href="#资源共享的方式" class="headerlink" title="资源共享的方式"></a>资源共享的方式</h4><ol><li>互斥共享方式</li></ol><p>系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，<strong>应规定在一段时间内只允许一个进程(线程)访问该资源</strong>。</p><p>系统中应建立一种机制，以<strong>保证对这类资源的互斥访问</strong>。当一个进程 A 要访<br>问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一进程对该资源进行访问。我们把这种资源共享方式称为<strong>互斥式共享</strong></p><p>把在一段时间内只允许一个进程访问的资源称为<strong>临界资源或独占资源</strong>。计<br>算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。</p><ol start="2"><li>同时访问方式</li></ol><p>系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替、地对该资源进行访问。</p><p>并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件</p><h3 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h3><p>操作系统中的所谓“虚拟” (Virtual) ，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西。相应地，用于实现虚拟的技术称为虚拟技术。</p><ol><li>时分复用技术<ul><li>虚拟处理机技术</li><li>虚拟设备技术</li></ul></li></ol><p>时分复用，亦即分时使用方式，它最早用于电信业中。为了提高信道的利用率，人们利用时分复用方式，将一条物理信道虚拟为多条逻辑信道，将每条信道供一对用户通话。</p><ol start="2"><li>空分复用技术<ul><li>虚拟磁盘技术</li><li>虚拟存储器技术</li></ul></li></ol><p>早在上世纪初，电信业中就使用频分复用技术来提高信道的利用率。它是将一个频率范围非常宽的信道，划分成多个频率范围较窄的信道，其中的任何一个频带都只供一对用户通话。</p><h3 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h3><p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。、在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。</p><p>可见，由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。</p><p>进程是以人们不可预知的速度向前推进，此即进程的异步性(Asynchronism)。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6之Set与Map</title>
    <link href="/posts/9c5f5996.html"/>
    <url>/posts/9c5f5996.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是<strong>成员的值都是唯一的，没有重复的值</strong>。</p><p><code>Set</code>本身是一个构造函数，用来生成数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.<span class="hljs-title function_">add</span>(x));<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>&#125;<br><span class="hljs-comment">//2 3 5 4 -</span><br></code></pre></td></tr></table></figure><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//例一</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]);<br>[...set]<br><span class="hljs-comment">//[1,2,3,4]</span><br><br><span class="hljs-comment">//例二</span><br><span class="hljs-keyword">const</span> items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]);<br>items.<span class="hljs-property">size</span> <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">//例三</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(doucment.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>));<br>set.<span class="hljs-property">size</span> <br><br><span class="hljs-comment">//类似于</span><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>doucment.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>)<br>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">div</span> =&gt;</span> set.<span class="hljs-title function_">add</span>(div));<br>set.<span class="hljs-property">size</span><br></code></pre></td></tr></table></figure><p>上面代码也展示了一种去除数组重复成员的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(array)]<br></code></pre></td></tr></table></figure><p>去除字符串里面重复字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(<span class="hljs-string">&#x27;ababbc&#x27;</span>)].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">NaN</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">NaN</span>;<br>set.<span class="hljs-title function_">add</span>(a);<br>set.<span class="hljs-title function_">add</span>(b);<br>set <span class="hljs-comment">// Set&#123;NaN&#125;</span><br></code></pre></td></tr></table></figure><p>两个对象总是不相等的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>set.<span class="hljs-title function_">add</span>(&#123;&#125;);<br>set.<span class="hljs-property">size</span> <span class="hljs-comment">//1</span><br>set.<span class="hljs-title function_">add</span>(&#123;&#125;);<br>set.<span class="hljs-property">size</span> <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h2 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h2><p>Set结构的实例有以下属性：</p><ul><li><code>Set.prototype.constructor</code>: 构造函数，默认就是Set函数</li><li><code>Set.prototype.size</code>: 返回Set实例的成员数</li></ul><p>Set实例的方法分为两大类：操作方法和遍历方法</p><p>操作方法</p><ul><li><code>Set.prototype.add(value)</code>:添加某个值，返回Set结构本身</li><li><code>Set.prototype.delete(value)</code>:删除某个值，返回一个布尔值，表示删除是否成功</li><li><code>Set.prototype.has(value)</code>:返回一个布尔值，表示该值是否在Set结构中</li><li><code>Set.prototype.clear()</code>: 清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法实例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">s.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>)<br><span class="hljs-comment">//2被加入两次</span><br><br>s.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//true</span><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">//false</span><br><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">2</span>);<br><br>s.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><p>Set结构的实例有四个遍历方法，可以用于遍历成员</p><ul><li><code>Set.prototype.keys()</code>: 返回键名的遍历器</li><li><code>Set.prototype.values()</code>: 返回键值的遍历器</li><li><code>Set.prototype.entries()</code>: 返回键值对应的遍历器</li><li><code>Set.prototype.forEach()</code>: 使用回调函数遍历每个成员</li></ul><p><code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用</p><h4 id="（1）keys-，values-，entries"><a href="#（1）keys-，values-，entries" class="headerlink" title="（1）keys()，values()，entries()"></a>（1）keys()，values()，entries()</h4><p><code>keys方法</code>，<code>values方法</code>，<code>entries方法</code> 返回的都是遍历器对象。由于Set结构没有键名，只有键值(或者说键名和键值是同一个值)。因此，keys方法和values方法行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">keys</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">//red</span><br><span class="hljs-comment">//green</span><br><span class="hljs-comment">//blue</span><br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">values</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">//red</span><br><span class="hljs-comment">//green</span><br><span class="hljs-comment">//blue</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> set.<span class="hljs-title function_">entries</span>())&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;<br><span class="hljs-comment">//[&quot;red&quot;,&quot;red&quot;]</span><br><span class="hljs-comment">//[&quot;green&quot;,&quot;green&quot;]</span><br><span class="hljs-comment">//[&quot;blue&quot;,&quot;blue&quot;]</span><br></code></pre></td></tr></table></figure><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === <span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">values</span><br><span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> set)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br><span class="hljs-comment">//red</span><br><span class="hljs-comment">//green</span><br><span class="hljs-comment">//blue</span><br></code></pre></td></tr></table></figure><h3 id="2-forEach"><a href="#2-forEach" class="headerlink" title="(2) forEach()"></a>(2) forEach()</h3><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]);<br>set.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&#x27; : &#x27;</span> + value))<br><span class="hljs-comment">// 1 : 1</span><br><span class="hljs-comment">// 4 : 4</span><br><span class="hljs-comment">// 9 : 9</span><br></code></pre></td></tr></table></figure><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p>Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>    [<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>],<br>    [<span class="hljs-string">&#x27;title&#x27;</span>,<span class="hljs-string">&#x27;Author&#x27;</span>]<br>])<br>map.<span class="hljs-property">size</span> <span class="hljs-comment">//2</span><br>map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">//true</span><br>map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">//&#x27;张三&#x27;</span><br>map.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<span class="hljs-comment">//true</span><br>map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<span class="hljs-comment">//&#x27;Author&#x27;</span><br></code></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>map.<span class="hljs-title function_">set</span>(-<span class="hljs-number">0</span>, <span class="hljs-number">123</span>);<br>map.<span class="hljs-title function_">get</span>(+<span class="hljs-number">0</span>) <span class="hljs-comment">// 123</span><br><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">1</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-number">2</span>);<br>map.<span class="hljs-title function_">get</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">4</span>);<br>map.<span class="hljs-title function_">get</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 3</span><br><br>map.<span class="hljs-title function_">set</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-number">123</span>);<br>map.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><h3 id="size属性"><a href="#size属性" class="headerlink" title="size属性"></a>size属性</h3><p><code>size</code>属性返回 Map 结构的成员总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br><br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="Map-prototype-set-key-value"><a href="#Map-prototype-set-key-value" class="headerlink" title="Map.prototype.set(key,value)"></a>Map.prototype.set(key,value)</h3><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>)        <span class="hljs-comment">// 键是字符串</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>)     <span class="hljs-comment">// 键是数值</span><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>)    <span class="hljs-comment">// 键是 undefined</span><br></code></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>  .<span class="hljs-title function_">set</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br>  .<span class="hljs-title function_">set</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>  .<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="Map-prototype-get-key"><a href="#Map-prototype-get-key" class="headerlink" title="Map.prototype.get(key)"></a>Map.prototype.get(key)</h3><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br><span class="hljs-keyword">const</span> hello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);&#125;;<br>m.<span class="hljs-title function_">set</span>(hello, <span class="hljs-string">&#x27;Hello ES6!&#x27;</span>) <span class="hljs-comment">// 键是函数</span><br><br>m.<span class="hljs-title function_">get</span>(hello)  <span class="hljs-comment">// Hello ES6!</span><br></code></pre></td></tr></table></figure><h3 id="Map-prototype-has-key"><a href="#Map-prototype-has-key" class="headerlink" title="Map.prototype.has(key)"></a>Map.prototype.has(key)</h3><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><br>m.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;edition&#x27;</span>, <span class="hljs-number">6</span>);<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-number">262</span>, <span class="hljs-string">&#x27;standard&#x27;</span>);<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;edition&#x27;</span>)     <span class="hljs-comment">// true</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;years&#x27;</span>)       <span class="hljs-comment">// false</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-number">262</span>)           <span class="hljs-comment">// true</span><br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Map-prototype-delete-key"><a href="#Map-prototype-delete-key" class="headerlink" title="Map.prototype.delete(key)"></a>Map.prototype.delete(key)</h3><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>m.<span class="hljs-title function_">set</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;nah&#x27;</span>);<br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)     <span class="hljs-comment">// true</span><br><br>m.<span class="hljs-title function_">delete</span>(<span class="hljs-literal">undefined</span>)<br>m.<span class="hljs-title function_">has</span>(<span class="hljs-literal">undefined</span>)       <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="Map-prototype-clear"><a href="#Map-prototype-clear" class="headerlink" title="Map.prototype.clear()"></a>Map.prototype.clear()</h3><p><code>clear</code>方法清除所有成员，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-literal">true</span>);<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-literal">false</span>);<br><br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 2</span><br>map.<span class="hljs-title function_">clear</span>()<br>map.<span class="hljs-property">size</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;no&#x27;</span>],<br>  [<span class="hljs-string">&#x27;T&#x27;</span>,  <span class="hljs-string">&#x27;yes&#x27;</span>],<br>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot;</span><br><span class="hljs-comment">// &quot;T&quot;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;<br><span class="hljs-comment">// &quot;no&quot;</span><br><span class="hljs-comment">// &quot;yes&quot;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item[<span class="hljs-number">0</span>], item[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br><br><span class="hljs-comment">// 等同于使用map.entries()</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> map) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;<br><span class="hljs-comment">// &quot;F&quot; &quot;no&quot;</span><br><span class="hljs-comment">// &quot;T&quot; &quot;yes&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">map[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === map.<span class="hljs-property">entries</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络之网络应用</title>
    <link href="/posts/a0d34108.html"/>
    <url>/posts/a0d34108.html</url>
    
    <content type="html"><![CDATA[<h3 id="网络应用体系结构"><a href="#网络应用体系结构" class="headerlink" title="网络应用体系结构"></a>网络应用体系结构</h3><ul><li><p>客户即/服务器结构(Client-Server,C/S)</p></li><li><p>点对点结构(Peer-to-Peer, P2P)</p></li><li><p>混合结构(Hybrid)</p></li></ul><h4 id="客户机-服务器结构"><a href="#客户机-服务器结构" class="headerlink" title="客户机/服务器结构"></a>客户机/服务器结构</h4><p>服务器</p><ul><li><strong>7*24小时提供服务</strong></li><li><strong>永久性访问地址/域名</strong></li><li>利用大量服务器实现可拓展性</li></ul><p>客户机</p><ul><li>与服务器通信，使用服务器提供的服务</li><li><strong>间歇性接入网络</strong></li><li><strong>可能使用动态IP地址</strong></li><li>不会与其他客户机直接通信</li></ul><p><img src="http://mark-imges.test.upcdn.net/images/20210724165115.png"></p><h4 id="纯P2P结构"><a href="#纯P2P结构" class="headerlink" title="纯P2P结构"></a>纯P2P结构</h4><ul><li>没有永远在线的服务器</li><li>任意端系统/节点之间可以直接通讯</li><li>节点间歇息接入网络</li><li>节点可能改变IP地址</li></ul><p>优点：<font color=red>高度可伸缩</font></p><p>缺点：<font color=red>难于管理</font></p><h4 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h4><p>混合结构的例子：</p><p><a href="https://baike.baidu.com/item/Napster/731754?fr=aladdin">Napster</a></p><ul><li>文件传输采用P2P结构</li><li>文件的搜索采用C/S结构 - 集中式<ul><li>每个节点向中央服务器登记自己的内容</li><li>每个节点向中央服务器提交查询请求，查找感兴趣的内容</li></ul></li></ul><h3 id="网络应用进程通信"><a href="#网络应用进程通信" class="headerlink" title="网络应用进程通信"></a>网络应用进程通信</h3><p>进程：</p><ul><li>主机上运行的程序</li></ul><p>同一主机运行的进行之间如何通信：</p><ul><li>进程间通信机制</li><li>操作系统提供</li></ul><p>不同主机运行的进程间如何通信</p><ul><li><font color=red>消息交换(报文交换)</font></li></ul><p>客户机进程：发起通信的进程</p><p>服务器进行：等待通信请求的进行</p><h4 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h4><p>进程间通信利用socket发送/接收消息实现</p><p>类似于寄信</p><ul><li>发送方将消息送到门外邮箱</li><li>发送方依赖门外的传输设备将消息传到接收方所在主机，并送到接收方的门外</li><li>接收方从门外获取消息</li></ul><p>传输基础设施向进程提供API</p><ul><li>传输协议的选择</li><li>参数的设置</li></ul><p>如何寻址进程？</p><p>不同主机的进程间通信，那么每个进程必须拥有<strong>标识符</strong></p><p>如何寻址主机？ <font color=red>IP地址</font></p><p>Q: 主机有了IP地址后，是否足以定位进程？</p><p>A: 否，同一主机可能同时有多个进程需要通信。</p><p><font color=red>端口号/Port number</font></p><ul><li>为主机上每个需要通信的进程分配一个端口号</li><li>HTTP Server: 80</li><li>Mail Server: 25</li></ul><p>进程的标识符</p><ul><li>IP地址+端口号</li></ul><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>网络应用需遵循应用层协议</p><p>公开协议</p><ul><li>由RFC(Request For Comments)定义</li><li>允许互操作</li><li>HTTP, SMTP, ……</li></ul><p>私有协议</p><ul><li>多数p2p文件共享应用</li></ul><p>应用层协议的内容</p><p>消息的类型(type)</p><ul><li>请求消息</li><li>响应消息</li></ul><p>消息的语法(Syntax)格式</p><ul><li>消息中有哪些字段(field)?</li><li>每个字段如何描述</li></ul><p>字段的语义(semantics)</p><ul><li>字段中消息的含义</li></ul><p>规则(rules)</p><ul><li>进程何时发送/响应消息</li><li>进程如何发送/响应消息</li></ul><h3 id="网络应用对传输服务的需求"><a href="#网络应用对传输服务的需求" class="headerlink" title="网络应用对传输服务的需求"></a>网络应用对传输服务的需求</h3><p>数据丢失(data loss)/可靠性(reliability)</p><ul><li>某些网络应用能够容忍一定的数据丢失：网络电话</li><li>某些网络应用要求100%可靠的数据传输：文件传输，telnet</li></ul><p>时间(timing)/延迟(delay)</p><ul><li>有些应用只有在延迟足够低时才能”有效”</li><li>网络电话/网络游戏</li></ul><p>带宽</p><ul><li>某些应用只有在带宽达到最低要求时才”有效”：网络视频</li><li>某些应用能够适应任何带宽 弹性应用：email</li></ul><h4 id="Internet提供的传输服务"><a href="#Internet提供的传输服务" class="headerlink" title="Internet提供的传输服务"></a>Internet提供的传输服务</h4><p>TCP服务</p><ul><li>面向连接：客户机/服务器进程间需要建立连接</li><li>可靠的传输</li><li>流量控制：发送方不会发送速度过快，超过接收方的处理能力</li><li>拥塞控制：当网络负载过重时能够限制发送方的发送速度</li><li>不提供时间/延迟保障</li><li>不提供最小带宽保障</li></ul><p>UDP服务</p><ul><li><p>无连接</p></li><li><p>不可靠的数据传输</p></li><li><p>不提供：</p><ul><li>可靠性保障</li><li>流量控制</li><li>拥塞控制</li><li>延迟保障</li><li>带宽保障</li></ul></li></ul><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><p>World Wide Web:    Tim Berners-Lee</p><ul><li>网页</li><li>网页互相链接</li></ul><p>网页包含多个对象</p><ul><li>对象：html文件，jpeg文件，视频文件，动态脚本</li><li>基本html文件：包含对其他对象引用的链接</li></ul><p>对象的寻址(addressing)</p><ul><li><p><font color=red>URL(Uniform Resourse Locator)</font>:    <strong>统一资源定位器</strong></p></li><li><p><font color=red>Scheme://host:port/path</font></p></li></ul><h4 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h4><p>万维网应用遵循什么协议？</p><p>超文本传输协议</p><ul><li><font color=red>HyperText Transfer Protocol</font></li></ul><p>C/S结构</p><ul><li>客户-Brower:    请求，接收，展示web对象</li><li>服务器-Web Server： 响应客户的请求，发送对象</li></ul><p>HTTP版本：</p><ul><li>1.0    RFC 1945</li><li>1.1    RFC 2068</li></ul><p>使用TCP传输服务</p><ul><li>服务器在80端口等待客户的请求</li><li>浏览器发起到服务器的TCP连接请求(创建套接字Socket)</li><li>服务器接受来自浏览器的TCP连接</li><li>浏览器(HTTP客户端)与Web服务器(HTTP服务器)交换HTTP消息</li><li>关闭TCP连接</li></ul><p><strong>无状态(stateless)</strong></p><ul><li><font color=red>服务器不维护任何有关客户端过去所请求的信息</font></li></ul><h4 id="HTTP连接的两种类型"><a href="#HTTP连接的两种类型" class="headerlink" title="HTTP连接的两种类型"></a>HTTP连接的两种类型</h4><p><font color=red>非持久化连接(Nonpersistent HTTP)</font></p><ul><li>每个TCP连接最多允许传输<strong>一个</strong>对象</li><li>HTTP1.0版本使用非持久化连接</li></ul><p><font color=red>持久化连接(Persistent HTTP)</font></p><ul><li>每个TCP连接允许传输<strong>多个</strong>对象</li><li>HTTP1.1版本默认使用持久化连接</li></ul><p>非持久性连接的问题</p><ul><li>每个对象需要两个RTT</li><li>操作系统需要为每个TCP连接开销资源</li><li>浏览器会怎么做<ul><li>打开多个并行的TCP连接以获取网页所需对象</li><li>给服务器端造成什么影响</li></ul></li></ul><p>持久性连接</p><ul><li>发送响应后，服务器保持TCP连接的打开</li><li>后续的HTTP消息可以通过这个连接发送</li></ul><p>无流水的持久性连接</p><ul><li>客户端只有收到前一个响应后才发送新的请求</li><li>每个被引用的对象耗时1个RTT</li></ul><p>带有流水机制的持久性连接</p><ul><li>HTTP1.1的默认选项</li><li>客户端只要遇到一个引用对象就尽快发出请求</li><li>理想情况下，收到所有的引用对象只需要耗时一个RTT</li></ul><h4 id="HTTP协议消息格式"><a href="#HTTP协议消息格式" class="headerlink" title="HTTP协议消息格式"></a>HTTP协议消息格式</h4><p>HTTP协议有两类消息</p><ul><li>请求消息(request)</li><li>响应消息(response)</li></ul><p>请求消息</p><ul><li>ASCII：人直接可读</li></ul><p><font color=red>HTTP请求消息的通用格式</font></p><p><img src="http://mark-imges.test.upcdn.net/images/20210725140607.png"></p><p>上传输入的方式</p><ul><li><font color=red>POST方法</font><ul><li>网页经常需要填写表格(form)</li><li>在请求消息的消息体(entity body)中上传客户端的输入</li></ul></li><li><font color=red>URL方法</font><ul><li><font color=red>使用GET方法</font></li><li>输入信息通过request行的URL字段上传</li></ul></li></ul><p>方法的类型</p><p>HTTP/1.0</p><ul><li>GET</li><li>POST</li><li>HEAD<ul><li>请Server不要将所请求的对象放入响应消息中</li></ul></li></ul><p><font color=red>HTTP/1.1</font></p><ul><li>GET,POST,HEAD</li><li>PUT<ul><li>将消息体中的文件上传到URL字段所指定的路径</li></ul></li><li>DELETE<ul><li>删除URL字段所指定的文件</li></ul></li></ul><p>HTTP响应消息</p><p><img src="http://mark-imges.test.upcdn.net/images/20210725141802.png"></p><p>HTTP响应状态代码</p><ul><li>响应消息的第一行</li><li>示例<ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Request</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul></li></ul><h4 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h4><p>某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据(通常是经过加密的)</p><p>Cookie的组件</p><ul><li>HTTP响应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，由浏览器管理</li><li>Web服务器的后台数据库</li></ul><p>Cookie的作用</p><ul><li>身份认证</li><li>购物车</li><li>推荐</li><li>Web e-mail</li><li>……</li></ul><p>隐私问题</p><h4 id="Web缓存-代理服务器技术"><a href="#Web缓存-代理服务器技术" class="headerlink" title="Web缓存/代理服务器技术"></a>Web缓存/代理服务器技术</h4><p>功能</p><ul><li>在不访问服务器的前提下满足客户端的HTTP请求</li></ul><p>为什么发明这种技术？</p><ul><li><font color=red>缩短客户请求的响应时间</font></li><li><font color=red>减少机构/组织的流量</font></li><li><font color=red>在大范围内(Internet)实现有效的内容分发</font></li></ul><p>Web缓存/代理服务器</p><ul><li>用户设定浏览器通过缓存进行Web访问</li><li>浏览器向缓存/代理服务器发送所有的HTTP请求<ul><li><strong>如果所请求对象在缓存中，缓存返回对象</strong></li><li><strong>否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存对象</strong></li></ul></li><li>缓存即充当客户端，也充当服务器</li><li>一般由ISP(Internet服务提供商)架设</li></ul><h3 id="Email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h3><h4 id="Email应用的构成组件"><a href="#Email应用的构成组件" class="headerlink" title="Email应用的构成组件"></a>Email应用的构成组件</h4><ul><li>邮件客户端(user agent)</li><li>邮件服务器</li><li><strong>SMTP协议(Simple Mail Transfer Protocol)</strong></li></ul><p>邮件客户端</p><ul><li>读，写Email信息</li><li>与服务器交互，收，发Email信息</li><li>Outlook，Foxmail，Thunderbird</li><li>Web客户端</li></ul><p>邮件服务器(Mail Server)</p><ul><li>邮箱：存储发给该用户的Email</li><li>消息队列(message queue)：存储等待发送的Email</li></ul><p>SMTP协议</p><ul><li>邮箱服务器之间传递消息所使用的协议</li><li>客户端：发送消息的服务器</li><li>服务器：接收消息的服务器</li></ul><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><ul><li>使用TCP进行email消息的可靠传输</li><li>端口25</li><li>传输过程的三个阶段<ul><li>握手</li><li>消息的传输</li><li>关闭</li></ul></li><li>命令/响应交互模式<ul><li><font color=red>命令(command)：ASCII文本</font></li><li><font color=red>响应(response)：状态代码和语句</font></li></ul></li><li>Email消息只能包含7位ASCII码</li><li>使用持久性连接</li><li>要求消息必须由7位ASCII码构成</li><li>SMTP服务器利用CRLF.CRLF确定消息的结束</li></ul><h4 id="Email消息格式"><a href="#Email消息格式" class="headerlink" title="Email消息格式"></a>Email消息格式</h4><p>文本消息格式标准</p><ul><li>同步行<ul><li>To</li><li>From</li><li>Subject</li></ul></li><li>消息体(body)<ul><li>消息本身</li><li>只能是ASCII字符</li></ul></li></ul><p>MIME：多媒体邮件扩展</p><ul><li>通过在邮件头部增加额外的行以声明MIME的内容类型</li></ul><h4 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h4><p>邮件访问协议：从服务器获取邮件</p><ul><li>POP：Post Office Protocol<ul><li>认证/授权(客户端&lt;-&gt;服务器)和下载</li></ul></li><li>IMAP：Internet Mail Access Protocol<ul><li>更多功能</li><li>更加复杂</li><li>能够操作服务器上存储的消息</li></ul></li><li>HTTP：163，QQ Mail等</li></ul><h4 id="POP协议"><a href="#POP协议" class="headerlink" title="POP协议"></a>POP协议</h4><p>认证过程</p><ul><li>客户端命令<ul><li>User：声明用户名</li><li>Pass：声明密码</li></ul></li><li>服务器响应<ul><li>+OK</li><li>-ERR</li></ul></li></ul><p>事务阶段</p><ul><li>List：列出消息数量</li><li>Retr：用编号获取消息</li><li>Dele：删除消息</li><li>Quit</li></ul><p>“下载并删除”模式</p><ul><li>用户如果换了客户端软件，无法重读该邮件</li></ul><p>“下载并保持”模式</p><ul><li>不同客户端可以保存消息的拷贝</li></ul><p>POP协议是无状态的</p><h4 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h4><p><strong>所以消息统一保存在一个地方：服务器</strong></p><p>允许用户利用文件夹组织消息</p><p>IMAP支持跨会话(Session)的用户状态：</p><ul><li>文件夹的名字</li><li>文件夹与消息ID之间的映射等</li></ul><h3 id="DNS应用"><a href="#DNS应用" class="headerlink" title="DNS应用"></a>DNS应用</h3><h4 id="DNS-Domain-Name-System"><a href="#DNS-Domain-Name-System" class="headerlink" title="DNS:    Domain Name System"></a>DNS:    Domain Name System</h4><p>Internet上主机/路由器的识别问题</p><ul><li>IP地址</li><li>域名：<a href="http://www.hit.edu.cn/">www.hit.edu.cn</a></li></ul><p>域名解析系统DNS</p><ul><li>多层命名服务器构成的分布式数据库</li><li>应用层协议：完成名字的解析<ul><li>Internet核心功能，用应用层协议实现</li><li>网络边界复杂</li></ul></li></ul><p>DNS服务</p><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li>负载均衡：web服务器</li></ul><h4 id="DNS根域名服务器"><a href="#DNS根域名服务器" class="headerlink" title="DNS根域名服务器"></a>DNS根域名服务器</h4><p>本地域名解析服务无法解析域名时，方位根域名服务器</p><p>根域名服务器</p><ul><li>如果不知道映射，访问权威域名服务器</li><li>获得映射</li><li>向本地域名服务器返回映射</li></ul><h4 id="TLD和权威域名解析服务器"><a href="#TLD和权威域名解析服务器" class="headerlink" title="TLD和权威域名解析服务器"></a>TLD和权威域名解析服务器</h4><p>顶级域名服务器(TLD,top-level domain)：负责com,org,net,edu等顶级域名和国家顶级域名，例如cn,uk,fr等</p><p>权威(Authoritative)域名服务器：组织的域名解析服务器，提供组织内部服务器的解析服务</p><ul><li>组织负责维护</li><li>服务器提供商负责维护</li></ul><h4 id="本地域名解析服务器"><a href="#本地域名解析服务器" class="headerlink" title="本地域名解析服务器"></a>本地域名解析服务器</h4><p>不严格属性层级体系</p><p>每个ISP有一个本地域名服务器</p><ul><li>默认域名解析服务器</li></ul><p>当主机进行DNS查询时，查询被发送到本地域名服务器</p><ul><li>作为代理(proxy)，将查询转发给(层级式)域名解析服务器系统</li></ul><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><p>资源记录(RR,resource records)</p><p>Type=A</p><ul><li>name：主机域名</li><li>value：IP地址</li></ul><p>Type=NS</p><ul><li>name：域(edu.cn)</li><li>value：该域权威域名解析服务器的主机域名</li></ul><p>Type=CNAME</p><ul><li>name：某一真实域名的别名</li><li>value：真实域名</li></ul><p>Type=MX</p><ul><li>value是与name相对应的邮件服务器</li></ul><h4 id="DNS协议与消息格式"><a href="#DNS协议与消息格式" class="headerlink" title="DNS协议与消息格式"></a>DNS协议与消息格式</h4><p>DNS协议：</p><ul><li>查询(query)和回复(reply消息)</li><li>消息格式相同</li></ul><p>消息头部</p><ul><li>Identification: 16位查询编号，回复使用相同的编号</li><li>flags<ul><li>查询或回复</li><li>期望递归</li><li>递归可以</li><li>权威回答</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络之网络应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript之Symbol类型</title>
    <link href="/posts/eabb124d.html"/>
    <url>/posts/eabb124d.html</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES5的对象属性名都是字符串，容易造成属性名冲突，比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就可能与现有的方法产生冲突。ES6引入了Symbol就从根本上防止属性名的冲突。</p><p>Symbol是一种新的原始数据类型，表示独一无二的值。它是JavaScript的第七种数据类型，前六种是：undifined,null,Boolean,String,Number,Object</p><p>Symbol值通过Symbol函数生成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">typeof</span> s<br><span class="hljs-comment">//&quot;symbol&quot;</span><br></code></pre></td></tr></table></figure><p><font color=red>注意</font>：<code>Symbol</code>函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，而不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，便于在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1  = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>)<br><br>s1 <span class="hljs-comment">//Symbol(foo)</span><br>s2 <span class="hljs-comment">//Symbo(bar)</span><br><br>s1.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">//&quot;Symbol(foo)&quot;</span><br>s2.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">//&quot;Symbol(bar)&quot;</span><br></code></pre></td></tr></table></figure><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br><span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span><span class="hljs-string">&#x27;abc&#x27;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(obj);<br>sym <span class="hljs-comment">//Symbol(abc);</span><br></code></pre></td></tr></table></figure><p><font color=red>注意</font>，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>();<br><br>s1 === s2 <span class="hljs-comment">//false</span><br><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>Symbol值不能与其他类型的值进行运算，会报错。但是Symbol值可以显式转为字符串，也可以转为布尔值，但是不可转为数值。</p><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>在读取Symbol值的描述时，可以将其转为字符串，但是用法不方便。ES2019提供了一个实例属性description,直接返回Symbol的描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>sym.<span class="hljs-property">description</span> <span class="hljs-comment">// &#x27;foo&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h2><p>由于每个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，保证不会出现同名的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-title class_">Symbol</span>()<br><br><span class="hljs-comment">//第一种写法</span><br><span class="hljs-keyword">let</span> a = &#123;&#125;;<br>a[mySymbol] = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<br><br><span class="hljs-comment">//第二种写法</span><br><span class="hljs-keyword">let</span> a = &#123;<br>    [mySymbol]: <span class="hljs-string">&#x27;Hello!&#x27;</span><br>&#125;<br><span class="hljs-comment">//第三种写法</span><br><span class="hljs-keyword">let</span> a = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(a,mySymbol,&#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello!&#x27;</span>&#125;);<br><br><span class="hljs-comment">//以上写法都得到同样的结果</span><br>a[mySymbol] <span class="hljs-comment">//&quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p><code>Symbol</code>作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>,<code>for...of</code>，循环中，也不会被<code>Object.keys()</code>,<code>Object.getOwnPropertyNames()</code>,<code>JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象所有Symbol属性名。该方法返回一个数组，成员是当前对象的所以Symbol属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cosnt obj = &#123;&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;b&#x27;</span>)<br><br>obj[a] = <span class="hljs-string">&#x27;Hello&#x27;</span><br>obj[b] = <span class="hljs-string">&#x27;World&#x27;</span><br><br><span class="hljs-keyword">const</span> objectSymbols = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj);<br><br>objectSymbols<br><span class="hljs-comment">// [Symbol(a),Symbol(b)]</span><br></code></pre></td></tr></table></figure><p>另外一个新的API，<code>Reflect.ownKeys()</code>方法可以返回所以类型的键名，包括常规键名和Symbol键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>[<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;my_key&#x27;</span>)]: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">enum</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">nonEnum</span>:<span class="hljs-number">3</span><br>&#125;<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(ojb)<br><span class="hljs-comment">// [&#x27;enum&#x27;,&#x27;nonEnum&#x27;,Symbol(my_key)]</span><br></code></pre></td></tr></table></figure><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><h2 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for(),Symbol.keyFor()"></a>Symbol.for(),Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 === s2 <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。</p><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s1)<span class="hljs-comment">// &#x27;foo&#x27;</span><br><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(s2)<span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p><font color=red>注意</font>，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">foo</span>();<br><span class="hljs-keyword">const</span> y = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x === y) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS判断数据类型</title>
    <link href="/posts/a4f46ae4.html"/>
    <url>/posts/a4f46ae4.html</url>
    
    <content type="html"><![CDATA[<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><strong><code>typeof</code></strong> 操作符返回一个字符串，表示未经计算的操作数的类型。</p><p>typeof 总是返回一个字符串</p><p><code>typeof</code> 可能的返回值</p><table><thead><tr><th>类型</th><th>结果</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td></tr><tr><td>Null</td><td>“object”</td></tr><tr><td>Boolean</td><td>“boolean”</td></tr><tr><td>Number</td><td>“number”</td></tr><tr><td>String</td><td>“string”</td></tr><tr><td>Function</td><td>“function”</td></tr></tbody></table><p><font color=red><code>typeof</code>常用于检测基本数据类型(Number,String,Boolean等) </font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>;<span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;hello js&quot;</span> <span class="hljs-comment">//&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//&quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;; <span class="hljs-comment">//&quot;function&quot;</span><br></code></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><p><code>instanceof</code> <font color=red>常用于检测引用数据类型(Array,Object,RegExp等)</font></p><h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><p>可以通过 <code>toString()</code> 来获取每个对象的类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，传递要检查的对象作为第一个参数，称为 <code>thisArg</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> toString = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>;<br><br>toString.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// [object Date]</span><br>toString.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>); <span class="hljs-comment">// [object String]</span><br>toString.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Math</span>); <span class="hljs-comment">// [object Math]</span><br><br><span class="hljs-comment">//Since JavaScript 1.8.5</span><br>toString.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><br>toString.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><br><br></code></pre></td></tr></table></figure><p><code>Object.prototype.toString.call()</code> <font color=red>可以较为全面的检测基本数据类型和引用数据类型</font></p><p>注意：此方法对低版本IE浏览器不能做到全面兼容</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>JS面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络概述</title>
    <link href="/posts/7c4ca347.html"/>
    <url>/posts/7c4ca347.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><p>计算机网络是<strong>通信技术</strong>与<strong>计算机技术</strong>紧密结合的产物</p><p>计算机网络就是一种通信网络</p><p>定义：计算机网络就是<font color='red'>互连的、自治的</font>计算机集合</p><p>自治：无主从关系</p><p>互连：互联互通</p><ul><li>通信链路</li></ul><p>通过交换网络互连主机</p><h2 id="什么是Internet-组成细节角度"><a href="#什么是Internet-组成细节角度" class="headerlink" title="什么是Internet - 组成细节角度"></a>什么是Internet - 组成细节角度</h2><p>全球最大的互联网络</p><ul><li>ISP(Internet Service Provider)网络互连的“<strong>网络之网络</strong>”</li></ul><p>数以百万计的互连的<strong>计算设备</strong>集合</p><ul><li><strong>主机</strong>(hosts) = <strong>端系统</strong>(end systems)</li><li>运行各种网络应用</li></ul><p><strong>通信链路</strong></p><ul><li>光纤，铜缆，无线电，卫星……</li></ul><p><strong>分组交换</strong>：转发分组(数据包)</p><ul><li>路由器(routers)和交换机(switches)</li></ul><h2 id="什么是Internet-服务角度"><a href="#什么是Internet-服务角度" class="headerlink" title="什么是Internet - 服务角度"></a>什么是Internet - 服务角度</h2><p>为网络应用提供通信服务的通信基础设施</p><ul><li>Web、VoIP、email、网络游戏、电子商务、社交网络……</li></ul><p>为网络应用提供<strong>应用编程接口</strong>(API)</p><ul><li>支持应用程序连接Internet,发送接收数据</li><li>提供类似于邮政系统的数据传输服务</li></ul><h2 id="计算机网络结构"><a href="#计算机网络结构" class="headerlink" title="计算机网络结构"></a>计算机网络结构</h2><p><strong>网络边缘</strong></p><ul><li>主机</li><li>网络应用</li></ul><p><strong>接入网络，物理介质</strong></p><ul><li>有线或无线通信链路</li></ul><p><strong>网络核心(核心网络)</strong></p><ul><li>互联的路由器(或分组转发设备)</li><li>网络之网络</li></ul><h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>主机(端系统)</p><ul><li>位于“网络边缘”</li><li>运行网络应用程序<ul><li>如：Web, email</li></ul></li></ul><p>客户/服务器(client/server)应用模式</p><ul><li>客户发送请求，接收服务器响应</li><li>如：Web应用，文件传输FTP应用</li></ul><p>对等(peer-peer,p2p)应用模式</p><ul><li>无(或不仅依赖)专用服务器</li><li>通信在对等实体之间之间进行</li><li>如：BT, Skype, QQ</li></ul><h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><p>如何将网络边缘接入核心网络</p><p>接入网络</p><ul><li>住宅(家庭)接入网络</li><li>机构接入网络(学校，企业等)</li><li>移动接入网络</li></ul><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>互联的路由器网络</p><p>网络核心的关键功能：<strong>路由+转发</strong></p><p><strong>路由(routing):</strong></p><ul><li>确定分组从源到目的传输路径</li><li>路由算法</li></ul><p><strong>转发(forwarding)</strong></p><ul><li>将分组从路由器的输入端口交换到正确的输出端口</li></ul><p>Q: 网络核心解决的基本问题：</p><p>如何实现数据从<strong>源主机</strong>通过网络核心送达<strong>目的主机</strong></p><p>A: 数据交换</p><h4 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h4><p>数据交换的类型</p><ul><li>电路交换</li><li>报文交换</li><li>分组交换</li></ul><p><strong>电路交换</strong></p><p>典型的电路交换网络：电话网络</p><p>电路交换的三个阶段：</p><ul><li>建立连接(呼叫/电路建立)</li><li>通信</li><li>释放连接(拆除电路)</li></ul><p><font color=red>独占资源</font></p><p><font color=red>多路复用</font>(multiplexing),简称复用，是通信技术中的基本概念</p><ul><li>链路/网络资源(如带宽)划分为“资源片”</li><li>将资源片分配给各路“呼叫”(calls)</li><li>每路呼叫<font color=red>独占</font>分配到的资源片进行通信</li><li>资源片可能“闲置”(无共享)</li></ul><p>典型的多路复用方法：</p><ul><li>频分多路复用(FDM)</li><li>时分多路复用(TDM)</li><li>波分多路复用(WDM)</li><li>码分多路复用(CDM)</li></ul><p><strong>报文交换</strong></p><p><font color=red>报文</font>：源(应用)发送信息整体，如一个文件</p><p><strong>分组交换</strong></p><p><font color=red>分组</font>：报文分拆出来的一系列相对较小的数据包</p><p>分组交换需要报文的<font color=red>拆分与重组</font></p><p>会产生额外开销</p><p><font color=red>存储-转发(store-and-forward)</font></p><p><strong>报文交换</strong>与<strong>分组交换</strong>均采用存储-转发交换方式</p><p>区别：</p><ul><li>报文交换以完整报文进行“存储-转发”</li><li>分组交换以较小的分组进行”存储-转发”</li></ul><p><font color=red>分组交换绝对优于电路交换？</font></p><ul><li><p>适用于<strong>突发</strong>数据传输网络</p><ul><li>资源充分共享</li><li>简单，无需呼叫建立</li></ul></li><li><p>可能<strong>产生拥塞</strong>：分组延迟和丢失</p><ul><li>需要协议处理可靠数据传输和拥塞控制</li></ul></li></ul><h2 id="计算机网络性能"><a href="#计算机网络性能" class="headerlink" title="计算机网络性能"></a>计算机网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><font color=red>速率</font>即<strong>数据率</strong>(data rate)或称<strong>数据传输速度</strong>或<strong>比特率</strong>(bit rate)</p><ul><li><p>单位时间(s)传输信息量(bit)</p></li><li><p>计算机网络中最重要的一个性能指标</p></li><li><p>单位：b/s (bps)、kb/s、Mb/s 、Gb/s</p></li><li><p>k=10<sup>3</sup>,M=10<sup>6</sup>,G=10<sup>9</sup></p></li></ul><p>速率通常指<font color=red>额定速率或标称速率</font></p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210915194257407.png" alt="image-20210915194257407"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>带宽(bandwidth)原本是指信号具有的频带宽度，即最高频率和最低频率之差，单位是赫兹(Hz)</p><p>网络的带宽，通常是数字信道所能传达的“<font color=red>最高数据率</font>”，单位：b/s(bps)</p><p><font color="green">网络设备所支持的最高速度</font></p><p>常用的带宽单位：</p><ul><li>kb/s ,Mb/s,Gb/s,Tb/s</li></ul><h3 id="吞吐量-率"><a href="#吞吐量-率" class="headerlink" title="吞吐量/率"></a>吞吐量/率</h3><p><font color=red>吞吐量</font>：表示在发送端与接收端之间传送数据速率(b/s)</p><ul><li>即时吞吐量：给定时刻的速率</li><li>平均吞吐量：一段时间的平均速率</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>指<font color=red>数据(报文/分组/比特流)</font>从网络(或链路)的一端传送到另一端所需的时间。也叫<font color=green>延迟或迟延</font>。单位是s。</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210915203011289.png" alt="image-20210915203011289"></p><ul><li>发送时延：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间。<code>发送时延 = 数据长度/信道带宽(发送速率)</code></li><li>传播时延：取决于电磁波传播速度和链路长度。 传播时延 = <code>信道长度 / 电磁波在信道上的传播速率</code></li><li>等待输出/入链路可用</li><li>检错找出口</li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 = 传播时延 × 带宽</p><p>链路的时延带宽积也称为以<font color=red>比特为单位的链路长度</font></p><h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><p>从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)总共经历的时延。</p><p>RTT越大，在收到确认之前，可用发送的数据就越多</p><p>RTT包括：</p><ul><li>往返传播时延 = 传播时延*2</li><li>末端处理时间</li></ul><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率</p><ul><li>信道利用率 <code>有数据通过时间/(有+无)数据通过时间</code></li><li>网络利用率<code>信道利用率加权平均值</code></li></ul><p><img src="http://mark-imges.test.upcdn.net/images/image-20210915211039552.png" alt="image-20210915211039552"></p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃(即丢包)</li><li>丢弃分组可能由前序结点或源重发(也可能不重发)</li></ul><p><strong>丢包率 = 丢包数/已发分组总数</strong></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>网络体系结构是从<font color=red>功能上</font>描述计算机网络结构</p><p>计算机网络体系结构简称网络体系结构是<font color=red>分层结构</font></p><p>每层遵循某个/些<font color=red>网络协议</font>完成本层功能</p><p>计算机网络体系结构是计算机网络的各层及其协议的集合</p><p>体系结构是一个计算机网络的<strong>功能层次及其关系</strong>的定义</p><p>体系结构是抽象的</p><h3 id="分层网络体系结构的基本概念"><a href="#分层网络体系结构的基本概念" class="headerlink" title="分层网络体系结构的基本概念"></a>分层网络体系结构的基本概念</h3><ul><li><p><strong>实体(entity)</strong> 表示任何可发送或接收信息的硬件或软件进程</p></li><li><p>协议是控制<strong>两个对等实体</strong>进行通信的规则的集合，协议是”水平的”</p></li><li><p>任一层实体需要使用<strong>下层</strong>服务，遵循本层协议，实现本层功能，向<strong>上层</strong>提供服务，服务是”垂直的”</p></li><li><p>下层协议的实现对上层的服务用户是<font color=red>透明的</font></p></li><li><p>同系统的相邻层实体间通过<font color=red>接口</font>进行交互，通过<font color=red>服务访问点SAP</font>(Service Access Point)，交换原语，指定请求的特定服务</p></li></ul><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>**开发系统互连(OSI)**参考模型是由国际化标准组织(ISO)于1984年提出的分层网络体系结构模型</p><p>目的是支持<font color=red>异构网络系统</font>的互联互通</p><p>异构网络系统互连的<strong>国际标准</strong></p><p>理解网络通信的最佳学习工具(理论模型)</p><ul><li>理论成功，市场失败</li></ul><p><font color=red>7层</font>(功能)，每层完成特定的网络功能</p><img src="http://mark-imges.test.upcdn.net/images/20210722162341.png" alt="OSI模型图" style="zoom:80%;" /><p>OSI参考模型解释的通信过程</p><p><img src="http://mark-imges.test.upcdn.net/images/20210722163011.png" alt="OSI模型通信过程"></p><p>OSI参考模型数据封装与通信过程</p><p><img src="http://mark-imges.test.upcdn.net/images/20210722163716.png" alt="osi数据封装通信过程"></p><h4 id="为什么需要数据封装"><a href="#为什么需要数据封装" class="headerlink" title="为什么需要数据封装"></a>为什么需要数据封装</h4><ul><li>增加<font color=red>控制信息</font><ul><li>构造协议数据单元(PDU)</li></ul></li><li>控制信息主要包括：<ul><li><font color=red>地址(Address)</font>：标识发送端/接收端</li><li><font color=red>差错检测编码(Error-detecting code)</font>：用于差错检测或纠正</li><li><font color=red>协议控制(Protocol control)</font>：实现协议功能的附加信息，如优先级(priority)，服务质量(Qos)，和安全控制等</li></ul></li></ul><h4 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h4><p>接口特性</p><ul><li>机械特性，电气特性，功能特性，规程特性</li></ul><p>比特编码</p><p>数据率</p><p>比特同步</p><ul><li>时钟同步</li></ul><p><font color=red>传输模式</font></p><ul><li>单工(Simplex)</li><li>半双工(half-duplex)</li><li>全双工(full-duplex)</li></ul><h4 id="数据链路层功能"><a href="#数据链路层功能" class="headerlink" title="数据链路层功能"></a>数据链路层功能</h4><p>负责结点-结点(node-to-node)数据传输</p><p>组帧(Framing)</p><p>物理寻址(Physical addressing)</p><ul><li>在帧头中增加发送端或接收端的物理地址标识数据帧的发送端和接收端</li></ul><p>流量控制(Flow control)</p><ul><li>避免淹没接收端</li></ul><p>差错控制(Error control)</p><ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul><p>访问(接入)控制(Access control)</p><ul><li>在任一给定时刻决定哪个设备拥有链路(物理介质)控制使用权</li></ul><h4 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h4><p>负责<strong>源主机到目的主机</strong>数据分组(packet)交付</p><ul><li>可能穿越多个网络</li></ul><p><font color=red>逻辑寻址(Logical addressing)</font></p><ul><li><font color=red>全局唯一</font>逻辑地址，确保数据分组被送到目的主机，如IP地址</li></ul><p>路由(Routing)</p><ul><li>路由器(或网关)互连网络，并路由分组至最终目的主机</li><li>路径选择</li></ul><p>分组转发</p><h4 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h4><p><font color=red>分段与重组</font></p><p><strong>SAP寻址</strong></p><ul><li>确保将完整报文提交给正确进程，如端口号</li></ul><p><img src="http://mark-imges.test.upcdn.net/images/20210722172447.png"></p><p>连接控制</p><p>流量控制</p><p>差错控制</p><h4 id="会话层功能"><a href="#会话层功能" class="headerlink" title="会话层功能"></a>会话层功能</h4><p><strong>对话控制</strong>(dialog controlling)</p><ul><li>建立，维护</li></ul><p>同步(synchroization)</p><ul><li>在数据流中插入”同步点”</li></ul><p>最”薄”的一层</p><h4 id="表示层功能"><a href="#表示层功能" class="headerlink" title="表示层功能"></a>表示层功能</h4><p>处理两个系统间交换信息的<font color=red>语法与语义(syntax and semantics)</font>问题</p><ul><li>数据表示转化<ul><li>转换为主机独立的编码</li></ul></li><li>加密解密</li><li>压缩解压缩</li></ul><h4 id="应用层功能"><a href="#应用层功能" class="headerlink" title="应用层功能"></a>应用层功能</h4><p>支持用户通过用户代理(如浏览器)或网络接口<strong>使用网络(服务)</strong></p><p>典型应用层服务：</p><ul><li>文件传输</li><li>电子邮件</li><li>Web</li><li>…….</li></ul><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><p><img src="http://mark-imges.test.upcdn.net/images/20210722174533.png" alt="everything over ip"></p><p><img src="http://mark-imges.test.upcdn.net/images/20210722174609.png" alt="ip over everything"></p><h3 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h3><p>综合OSI和TCP/IP的优点</p><ul><li><strong>应用层</strong>：支持各种网络应用<ul><li>FTP，SMTP，HTTP</li></ul></li><li><strong>传输层</strong>：进程-进程的数据传输<ul><li>TCP，UDP</li></ul></li><li><strong>网络层</strong>：源主机到目的主机的数据分组路由和转发<ul><li>IP协议，路由协议等</li></ul></li><li><strong>链路层</strong>：相邻网络元素(主机，交换机，路由器等)的数据传输<ul><li>以太网(Ethernet)，802.11(WIFI)，PPP</li></ul></li><li><strong>物理层</strong>：比特传输</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer 22 链表中倒数第k个节点</title>
    <link href="/posts/72c33327.html"/>
    <url>/posts/72c33327.html</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-双指针法"><a href="#方法一-双指针法" class="headerlink" title="方法一 双指针法"></a>方法一 双指针法</h4><p>解题思路可参考 <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/jian-zhi-offer-22-lian-biao-zhong-dao-sh-7u6x/">点击此处</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">k</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> getKthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> latter = head;<br>    <span class="hljs-keyword">let</span> former = head;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        former = former.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(former)&#123;<br>        latter = latter.<span class="hljs-property">next</span>;<br>        former = former.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> latter;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/jian-zhi-offer-22-lian-biao-zhong-dao-sh-7u6x/">链表中倒数第k个节点</a></p><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/solution/mian-shi-ti-22-lian-biao-zhong-dao-shu-di-kge-j-11/">面试题22. 链表中倒数第 k 个节点（双指针，清晰图解）</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21合并两个有序链表</title>
    <link href="/posts/6db59f6c.html"/>
    <url>/posts/6db59f6c.html</url>
    
    <content type="html"><![CDATA[<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-迭代法"><a href="#方法一-迭代法" class="headerlink" title="方法一 迭代法"></a>方法一 迭代法</h4><p>解题思路可参考 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/di-gui-he-bing-liang-ge-you-xu-lian-biao-hghk/">点击此处</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-comment">// 将此比喻成两队排列好的队伍重新排队</span><br>    <span class="hljs-keyword">let</span> head1 = l1,head2 = l2;<br>    <span class="hljs-comment">// 临时节点</span><br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 笨蛋节点，用来指向最后要返回的头结点</span><br>    <span class="hljs-keyword">let</span> dump = temp;<br>    <span class="hljs-keyword">if</span>(head1 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head2;<br>    <span class="hljs-keyword">if</span>(head2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head1;<br>    <span class="hljs-keyword">while</span>(head1 &amp;&amp; head2)&#123;<br>        <span class="hljs-keyword">if</span>(head1.<span class="hljs-property">val</span> &gt; head2.<span class="hljs-property">val</span>)&#123;<br>            temp.<span class="hljs-property">next</span> = head2;<br>            head2 = head2.<span class="hljs-property">next</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp.<span class="hljs-property">next</span> = head1;<br>            head1 = head1.<span class="hljs-property">next</span>;<br>        &#125;<br>        temp = temp.<span class="hljs-property">next</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(head1) temp.<span class="hljs-property">next</span> = head1;<br>    <span class="hljs-keyword">if</span>(head2) temp.<span class="hljs-property">next</span> = head2;<br>    <span class="hljs-keyword">return</span> dump.<span class="hljs-property">next</span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法二-递归法"><a href="#方法二-递归法" class="headerlink" title="方法二 递归法"></a>方法二 递归法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l1</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">l2</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;<br>    <span class="hljs-keyword">if</span>(l1 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;<br>    <span class="hljs-keyword">if</span>(l2 === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;<br>    <span class="hljs-keyword">if</span>(l1.<span class="hljs-property">val</span> &lt; l2.<span class="hljs-property">val</span>)&#123;<br>        l1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1.<span class="hljs-property">next</span>,l2)<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        l2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeTwoLists</span>(l1,l2.<span class="hljs-property">next</span>);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/di-gui-he-bing-liang-ge-you-xu-lian-biao-hghk/">合并两个有序链表</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>203移除链表元素</title>
    <link href="/posts/b0b085a9.html"/>
    <url>/posts/b0b085a9.html</url>
    
    <content type="html"><![CDATA[<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,6,3,4,5,6]</span>, val = <span class="hljs-number">6</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>, val = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[7,7,7,7]</span>, val = 7<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一（删除头结点时另做考虑）"><a href="#方法一（删除头结点时另做考虑）" class="headerlink" title="方法一（删除头结点时另做考虑）"></a>方法一（删除头结点时另做考虑）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">val</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeElements = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, val</span>) &#123;<br>   <span class="hljs-comment">//删除值相同的头结点后，可能新的头结点值也相等，循环解决</span><br>   <span class="hljs-keyword">while</span>(head &amp;&amp; head.<span class="hljs-property">val</span> === val)&#123;<br>       head = head.<span class="hljs-property">next</span>;<br>   &#125;<br>   <span class="hljs-keyword">if</span>(head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-keyword">let</span> cur = head;<br>   <span class="hljs-comment">//确保当前节点后还有节点</span><br>   <span class="hljs-keyword">while</span>(cur.<span class="hljs-property">next</span>)&#123;<br>       <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">next</span>.<span class="hljs-property">val</span> === val)&#123;<br>           cur.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           cur = cur.<span class="hljs-property">next</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="方法二（添加一个虚拟头结点）"><a href="#方法二（添加一个虚拟头结点）" class="headerlink" title="方法二（添加一个虚拟头结点）"></a>方法二（添加一个虚拟头结点）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">val</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> removeElements = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, val</span>) &#123;<br>   <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>   node.<span class="hljs-property">next</span> = head;<br>   <span class="hljs-keyword">let</span> cur = head;<br>   <span class="hljs-keyword">let</span> pre = node;<br>   <span class="hljs-keyword">while</span>(cur)&#123;<br>       <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">val</span> === val)&#123;<br>           pre.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>;<br>           cur = cur.<span class="hljs-property">next</span>;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           pre = cur;<br>           cur = cur.<span class="hljs-property">next</span>;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> node.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/solution/203yi-chu-lian-biao-yuan-su-by-lewis-dxstabdzew/">203.移除链表元素（三种方法</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动基础之flex布局</title>
    <link href="/posts/9c1d1cb1.html"/>
    <url>/posts/9c1d1cb1.html</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局"></a>什么是flex布局</h3><p>Flex是Flexible Box的缩写，意为’灵活的盒子‘，所以flex布局一般也叫弹性布局</p><h3 id="什么是flex容器"><a href="#什么是flex容器" class="headerlink" title="什么是flex容器"></a>什么是flex容器</h3><p>采用flex布局的元素，称为flex容器</p><p>.box{display: flex | inline-flex} </p><h3 id="什么是flex项目-flex-item"><a href="#什么是flex项目-flex-item" class="headerlink" title="什么是flex项目(flex item)"></a>什么是flex项目(flex item)</h3><p>flex容器的所有子元素自动成为容器成员，称为flex项目</p><p>项目默认沿主轴排列</p><p><img src="http://mark-imges.test.upcdn.net/images/bg2015071004.png" alt="img"></p><h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><ul><li>flex    容器为块级元素特性，占一行</li><li>inline-flex   容器为行内块元素特性，宽度被flex项目撑开</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><span style="background:pink;color:#333;">flex-direction</span> 属性决定了主轴的方向(即项目的排列方向)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br><span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><p>它可能有4个值。</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>默认情况下，项目都排列在一条线(又称“轴线”)上，<span style="background:pink;color:#333;">flex-wrap </span>属性定义，如果在一条轴线排列不下，如何换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><p>它有三个取值</p><ul><li>nowrap(默认)：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p><em>tips:</em></p><p>当设置flex-wrap: nowrap时，如果flex项目是定宽的盒子且一行排列不下时，flex项目的宽度会被压缩</p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p><strong>flex-flow</strong> 属性是 <strong>flex-direction</strong> 属性和 <strong>flex-wrap</strong> 属性的简写形式，默认值为row nowrap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br><span class="hljs-attribute">flex</span>-<span class="hljs-attribute">flex</span>: &lt;flex-direction&gt; | &lt;flex-wrap&gt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><span style="background:pink;color:#333">justify-content</span> 属性定义了项目在主轴上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/bg2015071010.png" alt="img"></p><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p><span style="background:pink;color:#333">align-items</span> 属性定义项目在<strong>交叉轴</strong>上如何对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/bg2015071011.png" alt="img"></p><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>align-content 属性定义了多根轴线(主轴线)的对齐方式，如果项目只有一跟轴线，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;<br>    <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/bg2015071012.png" alt="img"></p><p>该属性可能取6个值。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>order 属性定义项目的排列顺序，数值越小，排列越靠前</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br>    <span class="hljs-attribute">order</span>: &lt;integer&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p><span style="background:pink;color:#333">flex-grow</span> 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-attribute">flex-grow</span>: &lt;number&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p><span style="background:pink;color:#333">flex-shrink</span>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p><span style="background:pink;color:#333">flex-basis</span>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p><span style="background:pink;color:#333">flex</span>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]<br>&#125;<br></code></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p><span style="background:pink;color:#333">align-self</span>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://mark-imges.test.upcdn.net/images/bg2015071016.png" alt="img"></p><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰Flex布局教程语法篇</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206反转链表</title>
    <link href="/posts/46da0227.html"/>
    <url>/posts/46da0227.html</url>
    
    <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>示例一：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-string">[5,4,3,2,1]</span><br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p>示例 三：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h4><p>在遍历链表时，将当前节点的 next 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> cur = head,prev = <span class="hljs-literal">null</span>,tmp;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        tmp = cur.<span class="hljs-property">next</span>;<br>        cur.<span class="hljs-property">next</span> = prev;<br>        prev = cur;<br>        cur = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。</li><li>空间复杂度：O(1)。</li></ul><h4 id="方法二-递归法"><a href="#方法二-递归法" class="headerlink" title="方法二 递归法"></a>方法二 递归法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">ListNode</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-comment">//递归终止条件是当前为空，或者下一个节点为空</span><br>    <span class="hljs-keyword">if</span>(head === <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> === <span class="hljs-literal">null</span>)&#123;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>    <span class="hljs-comment">//这里的cur就是最后一个节点</span><br><span class="hljs-keyword">const</span> cur = <span class="hljs-title function_">reverseList</span>(head.<span class="hljs-property">next</span>);<br>    <span class="hljs-comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span><br>    <span class="hljs-comment">//而head是4，head的下一个是5，下下一个是空</span><br>    <span class="hljs-comment">//所以head.next.next 就是5-&gt;4</span><br>head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-comment">//防止链表循环，需要将head.next设置为空</span><br>head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">//每层递归函数都返回cur，也就是最后一个节点</span><br><span class="hljs-keyword">return</span> cur;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本题题解建议参考 <a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">点这里</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">动画演示+多种解法 206. 反转链表</a></p></li><li><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/">反转链表：双指针，递归，妖魔化的双指针</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/posts/8c70c103.html"/>
    <url>/posts/8c70c103.html</url>
    
    <content type="html"><![CDATA[<h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,3,2]</span><br>输出：<span class="hljs-comment">[2,3,1]</span><br></code></pre></td></tr></table></figure><p>限制：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 链表长度 &lt;= <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * function ListNode(val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *     this.next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">ListNode</span>&#125; <span class="hljs-variable">head</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reversePrint = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">let</span> cur = head;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        arr.<span class="hljs-title function_">push</span>(cur.<span class="hljs-property">val</span>);<br>        cur = cur.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reverse</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p><em>tips</em>:</p><p><strong>使用push+reverse而不是unshift理由：</strong></p><p>例如 <code>var arr = [1,2,3]</code><br>由于数组这种数据结构是有序的<br>那么我们按常理通常说当使用unshift插入到数组第一项时，后续的每一项都要向后移动一位，复杂度较高<br>而使用push追加至数组末尾，则只用改变一项，最终只使用reverse反转一次数组就OK</p><p><strong>但是在JS中是没有这个问题的，JS中使用push和unshift都可以，没有时间上的问题，主要是因为JS数组的内部实现同其他语言有区别</strong>，而我们这里依然强调使用push+reverse而不是unshift，目的是为了让大家统一思路，因为其他语言中类似于unshift的方法确实存在这个问题</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode两数之和</title>
    <link href="/posts/9d66cb49.html"/>
    <url>/posts/9d66cb49.html</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode两数之和"><a href="#LeetCode两数之和" class="headerlink" title="LeetCode两数之和"></a>LeetCode两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">给定 nums = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], target = <span class="hljs-number">9</span><br><br>因为 nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> + <span class="hljs-number">7</span> = <span class="hljs-number">9</span><br>所以返回 [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/two-sum">leetcode链接</a></p><h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><h4 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h4><p>时间复杂度：O(N^2)</p><p>空间复杂度：O(1)</p><p>思路及算法</p><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-property">length</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] + nums[j] === target)&#123;<br>            <span class="hljs-keyword">return</span> [i,j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法二：哈希表"><a href="#方法二：哈希表" class="headerlink" title="方法二：哈希表"></a>方法二：哈希表</h4><p>思路及算法</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><ul><li>这里我们可以增加一个 Map 记录已经遍历过的数字及其对应的索引值。这样当遍历一个新数字的时候就去 Map 里查询 <strong>target 与该数的差值是否已经在前面的数字中出现过</strong>。如果出现过，就找到了答案，就不必再往下继续执行了。</li><li>利用数组存储差值的索引位来减少一次遍历，降低时间复杂度为O(n);</li><li>用 <code>hashMap</code> 存储遍历过的元素和对应的索引。</li><li>每遍历一个元素，看看 hashMap 中是否存在满足要求的目标数字。</li><li>所有事情在一次遍历中完成（用了空间换取时间）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number[]</span>&#125; <span class="hljs-variable">nums</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">target</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number[]</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> twoSum = <span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) &#123;<br>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> diff = target - nums[i];<br>    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(diff)) &#123;<br>      <span class="hljs-keyword">return</span> [map.<span class="hljs-title function_">get</span>(diff), i];<br>    &#125;<br>    map.<span class="hljs-title function_">set</span>(nums[i], i);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动基础之视口标签</title>
    <link href="/posts/70752e5.html"/>
    <url>/posts/70752e5.html</url>
    
    <content type="html"><![CDATA[<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>1792x828像素分辨率</p><p>横向有828个点，纵向有1792个点</p><h2 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h2><p>物理像素(physical pixel)</p><p>也可称为<strong>设备像素</strong>(dp :device pixel)</p><p><em>tips:</em> 不同的屏幕物理像素所代表的区域可能大小不同，实际开发不使用物理像素</p><h2 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h2><p>也称<strong>逻辑像素</strong>(logical pixel),设备独立像素(dip: device independent pixel)</p><p>实际开发使用的像素</p><img src="http://mark-imges.test.upcdn.net/images/image-20210531202225443.png" alt="image-20210531202225443" style="zoom:80%;" /><p>在标清屏幕下，一个css像素(1x1)代表一个物理像素，而在高清屏幕下，一个css像素(1x1)代表4个物理像素(2x2)</p><img src="http://mark-imges.test.upcdn.net/images/image-20210531202434242.png" alt="image-20210531202434242" style="zoom:80%;" /><h2 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h2><p><strong>设备像素比</strong>(dpr: device pixel ratio)</p><p>dpr = 设备像素 / css像素（缩放比是1的情况下）</p><p><em>tips:</em> </p><p>dpr = 2 表示一个css像素用2x2个设备像素来绘制</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>改变的是CSS像素的大小</p><h2 id="PPi"><a href="#PPi" class="headerlink" title="PPi"></a>PPi</h2><p>每英寸的物理像素点</p><p>ppi: pixels per inch</p><p>dpi: dots per inch</p><h2 id="视口viewport"><a href="#视口viewport" class="headerlink" title="视口viewport"></a>视口viewport</h2><p><strong>基本概念</strong>：通常viewport是指视窗、视口，浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域。在移动端和pc端视口是不同的，pc端的视口是浏览器窗口区域，而在移动端有三个不同的视口概念：布局视口、视觉视口、理想视口</p><ul><li><p>布局视口：在浏览器窗口css的布局区域，布局视口的宽度限制css布局的宽。为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210531222823085.png" alt="image-20210531222823085"></p></li><li><p>视觉视口：用户通过屏幕看到的页面区域，通过缩放查看显示内容的区域，在移动端缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，当放大的时候，屏幕覆盖的css像素变少，视觉视口变小。</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210531222900711.png" alt="image-20210531222900711"></p></li><li><p>理想视口：一般来讲，这个视口其实不是真是存在的，它对设备来说是一个最理想布局视口尺寸，在用户不进行手动缩放的情况下，可以将页面理想地展示。那么所谓的理想宽度就是浏览器（屏幕）的宽度了。</p></li></ul><p>理想视口的设置方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,user-scalable=no,initial-scale=1.0,  maximum-scale=1.0,minimum-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在meta标签中，除了viewport这个很重要的属性，用来设置视口的一些行为,还有几个与其搭配一起使用的属性</p><table><thead><tr><th><strong>属性</strong></th><th><strong>含义</strong></th><th>取值</th></tr></thead><tbody><tr><td>width</td><td>定义视口的宽度，单位为像素</td><td>正整数或设备宽度device-width</td></tr><tr><td>height</td><td>定义视口的高度，单位为像素</td><td>正整数或device-height</td></tr><tr><td>initial-scale</td><td>定义初始缩放值</td><td>整数或小数</td></tr><tr><td>minimum-scale</td><td>定义缩小最小比例，它必须小于或等于maximum-scale设置</td><td>整数或小数</td></tr><tr><td>maximum-scale</td><td>定义放大最大比例，它必须大于或等于minimum-scale设置</td><td>整数或小数</td></tr><tr><td>user-scalable</td><td>定义是否允许用户手动缩放页面，默认值yes</td><td>yes/no</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903721697017864">掘金: 黑金团队</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/posts/65940d5a.html"/>
    <url>/posts/65940d5a.html</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>AJAX</strong>即“<strong>Asynchronous JavaScript and XML</strong>”（异步的<a href="https://www.wiki-wiki.top/baike-JavaScript">JavaScript</a>与<a href="https://www.wiki-wiki.top/baike-XML">XML</a>技术），指的是一套综合了多项技术的<a href="https://www.wiki-wiki.top/baike-%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://www.wiki-wiki.top/baike-%E7%B6%B2%E9%A0%81">网页</a>开发技术。</p><p>传统的Web应用允许用户端填写表单（form），当提交表单时就向<a href="https://www.wiki-wiki.top/baike-%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8">网页服务器</a>发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分<a href="https://www.wiki-wiki.top/baike-HTML">HTML</a>码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多</p><p>AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少，服务器回应更快了。同时，很多的处理工作可以在发出请求的<a href="https://www.wiki-wiki.top/baike-%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>机器上完成，因此Web服务器的负荷也减少了。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。</p><p>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#res-text&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">text</span>)&#123;<br>    textarea.<span class="hljs-property">innerText</span> = text;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span>(<span class="hljs-params">text</span>)&#123;<br>    textarea.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;Error code: &quot;</span> + text;<br>&#125;<br><span class="hljs-comment">// 新建xmlhttprequest对象</span><br><span class="hljs-keyword">var</span> xml = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 状态发生变化时，函数被回调</span><br>xml.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>(xml.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">if</span>(xml.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 成功，通过responseText拿到响应的文本</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(xml.<span class="hljs-property">responseText</span>);<br><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 失败，返回失败状态码</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(xml.<span class="hljs-property">status</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//发送请求</span><br><span class="hljs-comment">// 请求方式为Get,请求url为(一言接口)https://v1.hitokoto.cn</span><br><span class="hljs-comment">// get请求参数encode=text</span><br>xml.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;https://v1.hitokoto.cn?encode=text&#x27;</span>,&#123;<br><br>&#125;);<br>xml.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><hr><p>XmlHttpRequest对象在不同浏览器中不同的创建方法，以下是跨浏览器的通用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Provide the XMLHttpRequest class for IE 5.x-6.x:</span><br><span class="hljs-comment">// Other browsers (including IE 7.x-8.x) ignore this</span><br><span class="hljs-comment">//   when XMLHttpRequest is predefined</span><br><span class="hljs-keyword">var</span> xmlHttp;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">XMLHttpRequest</span> != <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>    xmlHttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">ActiveXObject</span>) &#123;<br>    <span class="hljs-keyword">var</span> aVersions = [<span class="hljs-string">&quot;Msxml2.XMLHttp.5.0&quot;</span>, <span class="hljs-string">&quot;Msxml2.XMLHttp.4.0&quot;</span>, <span class="hljs-string">&quot;Msxml2.XMLHttp.3.0&quot;</span>, <span class="hljs-string">&quot;Msxml2.XMLHttp&quot;</span>, <span class="hljs-string">&quot;Microsoft.XMLHttp&quot;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; aVersions.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            xmlHttp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveXObject</span>(aVersions[i]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当创建了<code>XMLHttpRequest</code>对象后，要先设置<code>onreadystatechange</code>的回调函数。在回调函数中，通常我们只需通过<code>readyState === 4</code>判断请求是否完成，如果已完成，再根据<code>status === 200</code>判断是否是一个成功的响应。</p><p><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，第一个参数指定是<code>GET</code>还是<code>POST</code>，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写。</p><p><em>注意</em>，千万不要把第三个参数指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</p><p>最后调用<code>send()</code>方法才真正发送请求。<code>GET</code>请求不需要参数，<code>POST</code>请求需要把body部分以字符串或者<code>FormData</code>对象传进去。</p><hr><h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p><font color=red>因为浏览器的同源策略，默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。</font>（否则会出现错误）</p><p>完全一致的意思是，域名要相同（<code>www.example.com</code>和<code>example.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口号要相同（默认是<code>:80</code>端口，它和<code>:8080</code>就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</p><h2 id="跨域访问"><a href="#跨域访问" class="headerlink" title="跨域访问"></a>跨域访问</h2><p>第一种：</p><p>JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源</p><p>第二种：CORS</p><p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p><p>了解CORS前，我们先搞明白概念：</p><p><strong>Origin</strong>表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p><p><img src="http://mark-imges.test.upcdn.net/images/20210303204619.png" alt="js-cors"></p><p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p><p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p><p>上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，<code>X-Custom: 12345</code>），通常能满足90%的需求。</p><p>对于PUT、DELETE以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个<code>OPTIONS</code>请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/path/to/resource</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>bar.com<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://my.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>POST<br></code></pre></td></tr></table></figure><p>服务器必须响应并明确指出允许的Method：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://my.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>POST, GET, PUT, OPTIONS<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>86400<br></code></pre></td></tr></table></figure><p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p><p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p><h2 id="参考文档来源"><a href="#参考文档来源" class="headerlink" title="参考文档来源"></a>参考文档来源</h2><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400">廖雪峰Ajax教程</a></p><p><a href="https://www.wiki-wiki.top/wiki/Ajax">维基百科Ajax</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript函数进阶</title>
    <link href="/posts/c584aaaa.html"/>
    <url>/posts/c584aaaa.html</url>
    
    <content type="html"><![CDATA[<h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><h3 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a>函数的定义方式</h3><p>1.函数声明方式function关键字(命名函数)</p><p>2.函数表达式(匿名函数)</p><p>3.new Function()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;参数1&#x27;</span>,<span class="hljs-string">&#x27;参数2&#x27;</span>,...<span class="hljs-string">&#x27;函数体&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>Function里面的参数都是字符串格式</li><li>第三种方式执行效率低,较少用</li><li>所有函数都是Function的实例(对象)</li><li>函数也属于对象</li></ul><p><img src="http://mark-imges.test.upcdn.net/images/20210129150739.png"></p><h3 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h3><p>1.普通函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello,world&#x27;</span>)<br>&#125;<br><span class="hljs-title function_">fn</span>();<br>fn.<span class="hljs-title function_">call</span>();<br></code></pre></td></tr></table></figure><p>2.对象的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello,world&#x27;</span>);<br>    &#125;<br>&#125;<br>o.<span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><p>3.构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>();<br></code></pre></td></tr></table></figure><p>4.绑定事件函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><p>5.定时器函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;,<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>6.立即执行函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello,world&#x27;</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="函数内this的指向"><a href="#函数内this的指向" class="headerlink" title="函数内this的指向"></a>函数内this的指向</h3><p>this的指向，是当我们调用函数的时候决定的，调用方式的不同决定了this的指向不同，一般指向我们的调用者</p><table><thead><tr><th>调用方式</th><th>this指向</th></tr></thead><tbody><tr><td>普通函数调用</td><td>window</td></tr><tr><td>构造函数调用</td><td>实例对象,原型对象里面的方法也指向实例对象</td></tr><tr><td>对象方法调用</td><td>该方法的所属对象</td></tr><tr><td>事件绑定方法</td><td>绑定事件对象</td></tr><tr><td>定时器函数</td><td>window</td></tr><tr><td>立即执行函数</td><td>window</td></tr></tbody></table><h3 id="改变函数内部this的指向"><a href="#改变函数内部this的指向" class="headerlink" title="改变函数内部this的指向"></a>改变函数内部this的指向</h3><p>javascript为我们提供了一些函数方法来帮我们更好的处理函数内部this的指向问题，常用的有bind(),call(),apply()三种方法</p><p>1.call方法</p><p>call()方法调用一个对象，简单理解为调用函数的方式，但是它可以改变函数的this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fun.<span class="hljs-title function_">call</span>(thisArg,arg1,arg2,...)<br></code></pre></td></tr></table></figure><ul><li>thisArg : 在fun函数运行时this的指向</li><li>arg1,arg2: 传递的参数</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>因此当我们想改变this的指向，同时想调用这个函数的时候，可以使用call，比如继承</li></ul><p>2.apply方法</p><p>apple()方法调用一个函数，简单理解为调用函数的方式，它可以改变函数的this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fun.<span class="hljs-title function_">apply</span>(thisArg,[argsArray])<br></code></pre></td></tr></table></figure><ul><li>thisArg: 在fun函数运行时指定的this值</li><li>argsArray: 传递的值，必须包含在数组里面</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>因此apply主要跟数组有关系，比如使用Math.max()求数组的最大值</li></ul><p>3.bind方法</p><p>bind()方法不会调用函数,但是能改变函数的this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fun.<span class="hljs-title function_">bind</span>(thisArg,arg1,arg2,...)<br></code></pre></td></tr></table></figure><ul><li>thisArg: 在fun函数运行时指定this值</li><li>arg1，arg2：传递的其他参数</li><li>返回由指定的this值和初始化参数改造的原函数拷贝</li><li>因此当我们只是2想改变this指向，不调用这个函数的时候，可以使用bind</li></ul><p><strong>call apply bind总结</strong></p><p>相同点</p><p>都可以改变函数内部的this指向</p><p>区别点</p><p>1.call和apply会调用函数，并且会改变内部this的指向</p><p>2.call和apply传递的参数不一样，call传递参数arg1，arg2…形式，apply必须数组形式[arg]</p><p>3.bind不会调用函数，可以改变函数内部的this指向</p><p>主要应用场景</p><p>1.call经常做继承</p><p>2.apply经常跟数组有关系，比如借助于数学对象实现数组最大值最小值</p><p>3.bind不调用函数，但是还想改变this指向，比如改变定时器内部this指向</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h3 id="什么是严格模式"><a href="#什么是严格模式" class="headerlink" title="什么是严格模式"></a>什么是严格模式</h3><p>javascript除了提供正常模式外，还提供了严格模式，ES5的严格模式是采用具有限制性javascript变体的一种方式，即在严格的条件下运行js代码</p><p>严格模式在IE10以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p><p>严格模式对正常的JavaScript语义做了一些更改：</p><ol><li>消除了Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。</li><li>消除代码运行的一些不安全之处，保证代码运行的安全。</li><li>提高编译器效率，增加运行速度。</li><li>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字如：class，，enum，export，extends，import，super 不能做变量名</li></ol><h3 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h3><p>严格模式可以应用到<strong>整个脚本</strong>或<strong>个别函数</strong>中。因此在使用时，我们可以将严格模式分为为<strong>脚本开启严格模式</strong>和为<strong>函数开启严格模式</strong>两种情况。</p><p>1.为脚本开启严格模式</p><p>为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”；（或‘use strict’；）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-meta"></span></span><br><span class="hljs-meta"><span class="language-javascript">    &quot;use strict&quot;</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是严格模式&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因为“use strict”加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。</p><p>有的script基本是严格模式，有的script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他 script脚本文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-string">&quot;use strict&quot;</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;</span><br><span class="language-javascript">    &#125;)();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.为函数开启严格模式</p><p>要给某个函数开启严格模式，需要把”use strict”声明放在函数体所有语句之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这是严格模式&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h3><p>1.变量规定</p><ol><li>在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须用var命令声明，然后在使用</li><li>严禁删除已经声明的变量，例如，delete x;语法是错误的</li></ol><p>2.严格模式下this的指向问题</p><ol><li>以前在全局作用域函数中的this指向window对象，严格模式下this指向的是undefinded</li><li>以前构造函数不加new也可以调用，当普通函数，this指向全局对象</li><li>严格模式下，如果构造函数不加new调用，this指向的是undefined如果给它赋值，会报错</li><li>new实例化的构造函数指向创建的对象实例</li><li>定时器this还是指向window</li><li>事件，对象还是指向调用者</li></ol><p>3.函数变化</p><ol><li>函数不能有重名的参数</li><li>函数必须声明在顶层，新版本的js会引入”块级作用域”（ES6已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数</li></ol><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p><strong>高阶函数</strong>是对其它函数进行操作的函数，它接<strong>收函数作为参数或将函数作为返回值输出</strong></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>1.变量作用域</p><p>变量根据作用域不同分两种：全局变量和局部变量</p><ol><li>函数内部可以使用全局变量</li><li>函数外部不可以使用局部变量</li><li>当函数执行完毕，本作用域的局部变量被销毁</li></ol><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包(closure)是指<strong>有权</strong>访问另一个函数作用域中<strong>变量</strong>的函数</p><p>简单理解就是，一个作用域可以访问另一个函数内部的局部变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">fn2</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-title function_">fn1</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>提问：我们如何在fn()函数外面访问fn()中的局部变量num呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> f = <span class="hljs-title function_">fn</span>();</span><br><span class="language-javascript">    <span class="hljs-title function_">f</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>闭包作用：延伸变量的作用范围</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js构造函数和原型</title>
    <link href="/posts/3309ee0a.html"/>
    <url>/posts/3309ee0a.html</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES6， 全称 ECMAScript 6.0 ，2015.06 发版。但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p><p>在 ES6之前 ，对象不是基于类创建的，而是用一种称为<strong>构建函数的特殊函数</strong>来定义对象和它们的特征。</p><p>创建对象可以通过以下三种方式：</p><ol><li>对象字面量</li><li>new Object()</li><li>自定义构造函数</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 JS 中，使用构造函数时要注意以下两点：</p><ol><li>构造函数用于创建某一类对象，其<strong>首字母要大写</strong></li><li>构造函数要<strong>和 new 一起使用</strong>才有意义</li></ol><p>new 在执行时会做四件事情：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要 return ）。</li></ol><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为<strong>静态成员</strong>和<strong>实例成员</strong>。</p><p>静态成员：在构造函数本上添加的成员称为<strong>静态成员</strong>，只能<strong>由构造函数本身来访问</strong><br>实例成员：在构造函数内部创建的对象成员称为<strong>实例成员</strong>，只能<strong>由实例化的对象来访问</strong></p><h2 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h2><p>构造函数方法很好用，但是<strong>存在浪费内存的问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Star</span>(<span class="hljs-params">uname,age</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = uname;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sing</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我会唱歌&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&#x27;刘德华&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Star</span>(<span class="hljs-string">&#x27;张学友&#x27;</span>,<span class="hljs-number">19</span>);<br></code></pre></td></tr></table></figure><img src="http://mark-imges.test.upcdn.net/images/20210123162304.png" style="zoom:80%;" /><h2 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h2><p>构造函数通过原型分配的函数是所有对象<strong>所共享的</strong>。</p><p>JavaScript 规定，<strong>每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象</strong>，这个对象的所有属性和方法，都会被构造函数所拥有。</p><p><font color=red>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</font></p><h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型__proto__</h2><p><font color=red>对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象</font>，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象<em>_proto_\</em> 原型的存在。</p><p>__proto__对象原型和原型对象 prototype 是等价的</p><p>__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p><img src="http://mark-imges.test.upcdn.net/images/20210123163401.png" style="zoom:80%;" /><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h2><p>对象原型（__proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，<strong>constructor 我们称为构造函数，因为它指回构造函数本身</strong>。</p><p>constructor 主要<strong>用于记录该对象引用于哪个构造函数</strong>，它可以让原型对象重新指向原来的构造函数。</p><p><strong>一般情况下，对象的方法都在构造函数的原型对象中设置</strong>。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><p><font color=red>构造函数，实例，原型对象三者的关系</font></p><img src="http://mark-imges.test.upcdn.net/images/20210123204210.png" style="zoom:80%;" /><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="http://mark-imges.test.upcdn.net/images/20210123204430.png"></p><h2 id="JavaScript的成员查找机制"><a href="#JavaScript的成员查找机制" class="headerlink" title="JavaScript的成员查找机制"></a>JavaScript的成员查找机制</h2><ol><li>当访问一个对象的属性（包括方法）时，首先<strong>查找这个对象自身有没有该属性</strong>。</li><li>如果<strong>没有就查找它的原型</strong>（也就是 __proto__指向的 prototype 原型对象）</li><li>如果<strong>还没有就查找原型对象的原型</strong>（Object的原型对象）。</li><li><strong>依此类推</strong>一直找到 Object 为止（null）。</li><li>__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ol><h2 id="原型对象this的指向"><a href="#原型对象this的指向" class="headerlink" title="原型对象this的指向"></a>原型对象this的指向</h2><p>构造函数中的this 指向我们实例对象.</p><p>原型对象里面放的是方法, <font color=red>这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象.</font></p><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><p><font color=red>注意：</font>数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES6之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为<strong>组合继承</strong>。</p><h3 id="借用构造函数继承父类属性"><a href="#借用构造函数继承父类属性" class="headerlink" title="借用构造函数继承父类属性"></a>借用构造函数继承父类属性</h3><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age,sex</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span> = sex;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name,age,sex</span>)&#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name,age,sex);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">score</span> = score;<br>&#125;<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(sl);<br></code></pre></td></tr></table></figure><h3 id="借用原型对象继承父类型方法"><a href="#借用原型对象继承父类型方法" class="headerlink" title="借用原型对象继承父类型方法"></a>借用原型对象继承父类型方法</h3><p><font color=red>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。</font></p><p>核心原理：</p><ol><li>将子类所共享的方法提取出来，<strong>让子类的 prototype 原型对象 = new 父类()</strong></li><li>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li><li>将<strong>子类的 constructor 从新指向子类的构造函数</strong></li></ol><h2 id="ES5新增方法概述"><a href="#ES5新增方法概述" class="headerlink" title="ES5新增方法概述"></a>ES5新增方法概述</h2><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue,index,arr</span>));<br><span class="hljs-comment">//currentValue 数组当前项值</span><br><span class="hljs-comment">//index 数组当前项索引</span><br><span class="hljs-comment">//arr 数组对象本身</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue,index,arr</span>));<br><span class="hljs-comment">//filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组</span><br><span class="hljs-comment">//注意它直接返回一个新数组</span><br><span class="hljs-comment">//currentValue 数组当前项的值</span><br><span class="hljs-comment">//index 数组当前索引</span><br><span class="hljs-comment">//arr 数组对象本身</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">some</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue, index, arr</span>));<br><span class="hljs-comment">//some() 方法用于检测数组中的元素是否满足指定条件. 通俗点 查找数组中是否有满足条件的元素</span><br><span class="hljs-comment">//注意它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.</span><br><span class="hljs-comment">//如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</span><br><span class="hljs-comment">//currentValue: 数组当前项的值</span><br><span class="hljs-comment">//index：数组当前项的索引</span><br><span class="hljs-comment">//arr：数组对象本身</span><br></code></pre></td></tr></table></figure><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><p>trim() 方法会从一个字符串的两端删除空白字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.<span class="hljs-title function_">trim</span>()<br><span class="hljs-comment">//trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</span><br></code></pre></td></tr></table></figure><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>Object.keys() 方法返回一个所有元素为字符串的数组。</p><p>Object.keys(obj);</p><p>Object.defineProperty() 定义新属性或修改原有的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj,prop,descriptor);<br><span class="hljs-comment">//obj 必须 目标对象</span><br><span class="hljs-comment">//prop 必须 需定义或修改的属性的名字</span><br><span class="hljs-comment">//descriptor 必须 目标属性所拥有的特性</span><br></code></pre></td></tr></table></figure><p>第三个参数descriptor说明</p><ul><li>value 设置属性的值</li><li>writable 值是否可以重写 true|false</li><li>enumerable 目标属性是否可被枚举 true|false</li><li>configurable 目标属性是否可以被删除或是否可以再次修改特性 true|false</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript面向对象</title>
    <link href="/posts/52c7327a.html"/>
    <url>/posts/52c7327a.html</url>
    
    <content type="html"><![CDATA[<h2 id="两大编程思想"><a href="#两大编程思想" class="headerlink" title="两大编程思想"></a>两大编程思想</h2><ul><li>面向过程</li><li>面向对象</li></ul><h2 id="面向过程编程介绍"><a href="#面向过程编程介绍" class="headerlink" title="面向过程编程介绍"></a>面向过程编程介绍</h2><p><strong>面向过程编程 POP(Process-oriented programming)</strong></p><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p><p><img src="http://mark-imges.test.upcdn.net/images/image-20210121140717828.png" alt="image-20210121140717828"></p><h2 id="面向对象编程介绍"><a href="#面向对象编程介绍" class="headerlink" title="面向对象编程介绍"></a>面向对象编程介绍</h2><p><strong>面向对象编程 OOP (Object Oriented Programming)</strong></p><p>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><p>举个栗子：将大象装进冰箱，面向对象做法。<br>先找出对象，并写出这些对象的功能：</p><ol><li>大象对象</li></ol><ul><li>进去</li></ul><ol start="2"><li>冰箱对象</li></ol><ul><li>打开</li><li>关闭</li></ul><ol start="3"><li>使用大象和冰箱的功能</li></ol><p>面向对象是以对象功能来划分问题，而不是步骤。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。<br>面向对象编程具有灵活、代码可复用、容易维护和开发的优点，更适合多人合作的大型软件项目。</p><p>面向对象的特性：</p><ul><li>封装性</li><li>继承性</li><li>多态性 </li></ul><h2 id="面向过程和面向对象的对比"><a href="#面向过程和面向对象的对比" class="headerlink" title="面向过程和面向对象的对比"></a>面向过程和面向对象的对比</h2><p><font color=red>面向过程</font>:</p><ul><li>优点：性能比面向对象高，适合跟硬件联系紧密的东西，例如单片机</li><li>缺点：没有面向对象容易维护，易复用，易扩展</li></ul><p><font color=red>面向对象</font>:</p><ul><li>优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护</li><li>缺点：性能比面向过程低</li></ul><h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><p>面向对象更贴近我们的实际生活, 可以使用面向对象描述现实世界事物. 但是事物分为具体的事物和抽象的事物</p><p>面向对象的思维特点:</p><ol><li>抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板)</li><li>对类进行实例化, 获取类的对象</li></ol><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>现实生活中：万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如，一本书、一辆汽车、一个人，可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。</p><p><strong>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象</strong>，例如字符串、数值、数组、<br>函数等</p><p>对象由<strong>属性</strong>和<strong>方法</strong>组成的：</p><p>属性：事物的<strong>特征</strong>，在对象中用属性来表示（常用名词）</p><p>方法：事物的<strong>行为</strong>，在对象中用方法来表示（常用名词）</p><h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><p>在 ES6 中新增加了类的概念，可以使用 <strong>class 关键字</strong>声明一个类，之后以这个类来<strong>实例化对象</strong>。</p><p>类抽象了对象的公共部分，它<strong>泛指</strong>某一大类（class）<br>对象<strong>特指</strong>某一个，通过类实例化一个具体的对象</p><p>创建类</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">name</span>&#123;<br><span class="hljs-comment">//class body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> <span class="hljs-title function_">name</span>();<br></code></pre></td></tr></table></figure><p><font color=red>注意：类必须使用new实例化对象</font></p><h3 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h3><p><strong>constructor() 方法</strong>是类的构造函数(默认方法)，<strong>用于传递参数,返回实例对象</strong>，通过 new 命令生成对象实例时，自动调用该方法。如果没有显示定义, 类内部会自动给我们创建一个constructor()</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<span class="hljs-comment">//构造方法或构造函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh.<span class="hljs-property">name</span>)<span class="hljs-comment">//&#x27;刘德华&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="类添加方法"><a href="#类添加方法" class="headerlink" title="类添加方法"></a>类添加方法</h3><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<span class="hljs-comment">//构造方法或构造函数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;你好&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;刘德华&#x27;</span>,<span class="hljs-number">18</span>);<br>ldh.<span class="hljs-title function_">say</span>();<br></code></pre></td></tr></table></figure><p><font color=red>注意： 方法之间不能加逗号分隔，同时方法不需要添加 function 关键字。</font></p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承</p><p>现实中的继承：子承父业，比如我们都继承了父亲的姓。</p><p>程序中的继承：子类可以继承父类的一些属性和方法。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-comment">//父类</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span>&#123;<br><span class="hljs-comment">//子类继承父类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">surname</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>= surname;<br>    &#125;<br>    <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你的姓是&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span><br>&#125;<br><span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;刘&#x27;</span>);<br>damao.<span class="hljs-title function_">say</span>();<br></code></pre></td></tr></table></figure><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super 关键字用于访问和调用对象父类上的函数。可以<strong>调用父类的构造函数</strong>，也可以调用父类的普通函数</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-comment">// 父类</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">surname</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span> = surname;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123; <span class="hljs-comment">// 子类继承父类</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">surname,firstname</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(surname); <span class="hljs-comment">// 调用父类的constructor(surname)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstname</span> = firstname; <span class="hljs-comment">// 定义子类独有的属性</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=red>注意: 子类在构造函数中使用super, 必须放到 this 前面 (必须先调用父类的构造方法,在使用子类构造方法)</font></p><p>调用父类的普通函数</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是爸爸&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Father</span>&#123;<br><span class="hljs-title function_">say</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//super调用父类的方法</span><br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">say</span>() + <span class="hljs-string">&#x27;的儿子&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> damo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(damo.<span class="hljs-title function_">say</span>());<br></code></pre></td></tr></table></figure><h2 id="三个注意点"><a href="#三个注意点" class="headerlink" title="三个注意点"></a>三个注意点</h2><ol><li>es6中类没有变量提升，所以必须先定义类，才能通过类实例化对象</li><li>类里面的共有属性和方法一定要加this使用</li><li>类里面的this指向问题</li><li>constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树(C语言实现)</title>
    <link href="/posts/1a682d7.html"/>
    <url>/posts/1a682d7.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p><strong>二叉搜索树</strong>（BST，Binary Search Tree）也称<strong>二叉排序树</strong>或<strong>二叉查找树</strong></p><p>特点：</p><ol><li>非空左子树的所有键值小于其根节点的键值</li><li>非空右子树的所有键值大于其根节点的键值</li><li>左右子树都是二叉搜索树</li></ol><p><img src="http://mark-imges.test.upcdn.net/images/20201205163345.png" alt="二叉查找树特别函数"></p><p><img src="http://mark-imges.test.upcdn.net/images/20201205163642.png" alt="查找操作"></p><h2 id="二叉搜索树的查找操作Find"><a href="#二叉搜索树的查找操作Find" class="headerlink" title="二叉搜索树的查找操作Find"></a>二叉搜索树的查找操作Find</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X,BinTree BST)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//查找失败</span><br>    <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X,BST-&gt;Right);<span class="hljs-comment">//在右子树中继续查找</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X,BST-&gt;Left);<span class="hljs-comment">//在左子树中继续查找</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">//查找成功，返回节点的地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于<em>非递归函数</em>的执行效率高，可将”尾递归”函数改为<em>迭代函数</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Position <span class="hljs-title">IterFind</span><span class="hljs-params">(ElementType X,BinTree BST)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(BST)&#123;<br>        <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>            BST = BST-&gt;Right;<span class="hljs-comment">//向右子树继续查找</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>            BST = BST-&gt;Left;<span class="hljs-comment">//向左子树继续查找</span><br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">//查找成功</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>查找效率取决于树的高度</strong></p><p><img src="http://mark-imges.test.upcdn.net/images/20201205164913.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找最小元素的递归函数</span><br><span class="hljs-function">Position <span class="hljs-title">FindMin</span><span class="hljs-params">(BinTree BST)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!BST-&gt;Left)<br>        <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">//找到最左节点并返回</span><br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">FindMin</span>(BST-&gt;Left);<span class="hljs-comment">//沿左分支继续查找</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//查找最大元素的迭代函数</span><br><span class="hljs-function">Position <span class="hljs-title">FindMax</span><span class="hljs-params">(BinTree BST)</span></span>&#123;<br><span class="hljs-keyword">if</span>(BST)&#123;<br>        <span class="hljs-keyword">while</span>(BST-&gt;Right) BST = BST-&gt;Right;<br>        <span class="hljs-comment">//沿右分支继续查找，直到最右叶节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BinTree <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X,BinTree BST)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST)&#123;<br>        <span class="hljs-comment">//若原树为空，生成并返回一个节点的二叉搜索树</span><br>        BST = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>        BST-&gt;Data = X;<br>        BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>            BST-&gt;Left = <span class="hljs-built_in">Insert</span>(X,BST-&gt;Left);<br>        <span class="hljs-comment">//递归插入左子树</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)&#123;<br>            BST-&gt;Right = <span class="hljs-built_in">Insert</span>(X,BST-&gt;Right);<br>            <span class="hljs-comment">//递归插入右子树</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的删除操作"><a href="#二叉树的删除操作" class="headerlink" title="二叉树的删除操作"></a>二叉树的删除操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BinTree <span class="hljs-title">Delete</span><span class="hljs-params">(ElementType X,BinTree BST)</span></span>&#123;<br>    Position Tmp;<br>    <span class="hljs-keyword">if</span>(!BST) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>        BST-&gt;Left = <span class="hljs-built_in">Delete</span>(X,BST-&gt;Left);<span class="hljs-comment">//左子树递归删除</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>        BST-&gt;Right = <span class="hljs-built_in">Delete</span>(X,BST-&gt;Right);<span class="hljs-comment">//右子树递归删除</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">if</span>(BST-&gt;Left&amp;&amp;BST-&gt;Right)&#123;<br>            Tmp = <span class="hljs-built_in">FindMin</span>(BST-&gt;Right);<br>            BST-&gt;Data = Tmp-&gt;Data;<br>            BST-&gt;Right = <span class="hljs-built_in">Delete</span>(BST-&gt;Data,BST-&gt;Right);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>Tmp = BST;<br>            <span class="hljs-keyword">if</span>(!BST-&gt;Left)<br>                BST=BST-&gt;Right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!BST-&gt;Right)<br>                BST=BST-&gt;Left;<br>            <span class="hljs-built_in">free</span>(Tmp);<br>        &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript对象</title>
    <link href="/posts/fe8c896.html"/>
    <url>/posts/fe8c896.html</url>
    
    <content type="html"><![CDATA[<h2 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h2><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种<strong>无序的复合数据集合</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br><span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔。</p><h2 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h2><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br><span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果键名是数值，会被自动转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-number">3.2</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-number">1e2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">1e-2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">.234</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">0xFF</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>obj<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   1: &quot;a&quot;,</span><br><span class="hljs-comment">//   3.2: &quot;b&quot;,</span><br><span class="hljs-comment">//   100: true,</span><br><span class="hljs-comment">//   0.01: true,</span><br><span class="hljs-comment">//   0.234: true,</span><br><span class="hljs-comment">//   255: true</span><br><span class="hljs-comment">// &#125;</span><br><br>obj[<span class="hljs-string">&#x27;100&#x27;</span>] <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">p</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">p</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的属性<code>p</code>，就指向一个函数。</p><p>如果属性的值还是一个对象，就形成了链式引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><br>o1.<span class="hljs-property">foo</span> = o2;<br>o1.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span> <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p><p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">p</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">m</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; ... &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，<code>m</code>属性后面的那个逗号，有没有都可以。</p><p>属性可以动态创建，不必在对象声明时就指定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">foo</span> = <span class="hljs-number">123</span>;<br>obj.<span class="hljs-property">foo</span> <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p><h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>o2.<span class="hljs-property">a</span> <span class="hljs-comment">// 1</span><br><br>o2.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br>o1.<span class="hljs-property">b</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1 = <span class="hljs-number">1</span>;<br>o2 <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p><p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> y = x;<br><br>x = <span class="hljs-number">2</span>;<br>y <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p><h2 id="表达式还是语句"><a href="#表达式还是语句" class="headerlink" title="表达式还是语句"></a>表达式还是语句</h2><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;<br></code></pre></td></tr></table></figure><p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p><p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) &#125; <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面的语句是一个代码块，而且只有解释为代码块，才能执行。</p><p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;) <span class="hljs-comment">// 正确</span><br>(&#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">123</span>) &#125;) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="hljs-comment">// &#123;foo: 123&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p><h2 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h2><h3 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h3><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj.<span class="hljs-property">p</span> <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-string">&#x27;p&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p><p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>&#125;;<br><br>obj.<span class="hljs-property">foo</span>  <span class="hljs-comment">// 1</span><br>obj[foo]  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p><p>方括号运算符内部还可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj[<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; world&#x27;</span>]<br>obj[<span class="hljs-number">3</span> + <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>数字键可以不加引号，因为会自动转成字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0.7</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj[<span class="hljs-string">&#x27;0.7&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-number">0.7</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p><p>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">123</span>: <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;;<br><br>obj<span class="hljs-number">.123</span> <span class="hljs-comment">// 报错</span><br>obj[<span class="hljs-number">123</span>] <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。</p><h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br>obj.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>obj[<span class="hljs-string">&#x27;bar&#x27;</span>] = <span class="hljs-string">&#x27;World&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值。</p><p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.<span class="hljs-property">p</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h3><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">key1</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">key2</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br><span class="hljs-comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;] 返回数组</span><br></code></pre></td></tr></table></figure><h3 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj) <span class="hljs-comment">// [&quot;p&quot;]</span><br><br><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">p</span> <span class="hljs-comment">// true</span><br>obj.<span class="hljs-property">p</span> <span class="hljs-comment">// undefined</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p><p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p><p><strong>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>,<br>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.<span class="hljs-property">p</span> <span class="hljs-comment">// 123</span><br><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">p</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">delete</span> obj.<span class="hljs-property">toString</span> <span class="hljs-comment">// true</span><br>obj.<span class="hljs-property">toString</span> <span class="hljs-comment">// function toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p><h3 id="属性是否存在"><a href="#属性是否存在" class="headerlink" title="属性是否存在"></a>属性是否存在</h3><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><font color='red'><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</font></p><p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p><h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;键名：&#x27;</span>, i);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;键值：&#x27;</span>, obj[i]);<br>&#125;<br><span class="hljs-comment">// 键名： a</span><br><span class="hljs-comment">// 键值： 1</span><br><span class="hljs-comment">// 键名： b</span><br><span class="hljs-comment">// 键值： 2</span><br><span class="hljs-comment">// 键名： c</span><br><span class="hljs-comment">// 键值： 3</span><br></code></pre></td></tr></table></figure><p><code>for...in</code>循环有两个使用注意点。</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。**(如该属性是”不可遍历”的,则不会遍历)**</li></ul><p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-comment">// toString 属性是存在的</span><br>obj.<span class="hljs-property">toString</span> <span class="hljs-comment">// toString() &#123; [native code] &#125;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);<br>&#125; <span class="hljs-comment">// 没有任何输出</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。</p><p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;老张&#x27;</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-keyword">if</span> (person.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p><code>with</code>语句的格式如下：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title function_">with</span> (对象) &#123;<br>  语句;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br>obj.<span class="hljs-property">p1</span> = <span class="hljs-number">4</span>;<br>obj.<span class="hljs-property">p2</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">with</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">links</span>[<span class="hljs-number">0</span>])&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(href);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style);<br>&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">links</span>[<span class="hljs-number">0</span>].<span class="hljs-property">href</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">links</span>[<span class="hljs-number">0</span>].<span class="hljs-property">title</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">links</span>[<span class="hljs-number">0</span>].<span class="hljs-property">style</span>);<br></code></pre></td></tr></table></figure><p><font color='red'>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><br>obj.<span class="hljs-property">p1</span> <span class="hljs-comment">// undefined</span><br>p1 <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p><p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。<font color='red'>因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">with</span>(<span class="hljs-params">obj1.obj2.obj3</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 + p2);<br>&#125;<br><br><span class="hljs-comment">// 可以写成</span><br><span class="hljs-keyword">var</span> temp = obj1.<span class="hljs-property">obj2</span>.<span class="hljs-property">obj3</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(temp.<span class="hljs-property">p1</span> + temp.<span class="hljs-property">p2</span>);<br></code></pre></td></tr></table></figure><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><font color="blue">本文仅作为个人笔记记录，如需了解完整教程可参考</font></p><p><a href="https://wangdoc.com/javascript/types/number.html">网道Javascript教程</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript数值</title>
    <link href="/posts/b266adad.html"/>
    <url>/posts/b266adad.html</url>
    
    <content type="html"><![CDATA[<h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这就是说，<font color="red">JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。</font>容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算</p><h2 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h2><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p><ul><li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li><li>第2位到第12位（共11位）：指数部分</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">(-<span class="hljs-number">1</span>)^符号位 * <span class="hljs-number">1.</span>xx.<span class="hljs-built_in">..xx</span> * <span class="hljs-number">2</span>^指数部分<br></code></pre></td></tr></table></figure><p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p><p><strong>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</strong></p><h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。</p><p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code></p><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span> <span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-title class_">Number</span>.<span class="hljs-property">MIN_VALUE</span> <span class="hljs-comment">// 5e-324</span><br></code></pre></td></tr></table></figure><h2 id="数值表示方法"><a href="#数值表示方法" class="headerlink" title="数值表示方法"></a>数值表示方法</h2><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制），数值也可以采用科学计数法表示</p><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p><ul><li><strong>小数点前的数字多于21位</strong></li><li><strong>小数点后的零多于5个。</strong></li></ul><h2 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h2><p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p><p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p><h2 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h2><p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的</p><p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p><p>除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的</p><h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span>-<span class="hljs-string">&#x27;x&#x27;</span><span class="hljs-comment">//NaN</span><br></code></pre></td></tr></table></figure><p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）</p><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span> <span class="hljs-comment">//&quot;Number&quot;</span><br></code></pre></td></tr></table></figure><p><code>NaN</code>不等于任何值，包括它本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">NaN</span>===<span class="hljs-title class_">NaN</span> <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p><p>NaN<code>在布尔运算时被当作</code>false</p><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p><h2 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h2><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><ul><li><p><code>parseInt</code>方法用于将字符串转为整数。</p></li><li><p>如果字符串头部有空格，空格会被自动去除</p></li><li><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p></li><li><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8a&#x27;</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12**&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.34&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15e2&#x27;</span>) <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15px&#x27;</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><ul><li><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p></li><li><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code></p></li><li><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x10&#x27;</span>) <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;011&#x27;</span>) <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><ul><li>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><h4 id="parseInt的进制转换"><a href="#parseInt的进制转换" class="headerlink" title="parseInt的进制转换"></a>parseInt的进制转换</h4><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>) <span class="hljs-comment">// 1000</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 1000</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 216</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 512</span><br></code></pre></td></tr></table></figure><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">// 43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-title class_">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p><code>parseFloat</code>方法用于将一个字符串转为浮点数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p>如果字符串符合科学计数法，则会进行相应的转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;314e-2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;0.0314E+2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></td></tr></table></figure><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>([]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;FF2&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>(&#123;&#125;)) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>]) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">Number</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>])) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>([]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-number">123</span>]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;123&#x27;</span>]) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p><p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myIsNaN</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> value !== value;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-title class_">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><font color="blue">本文仅作为个人笔记记录，如需了解完整教程可参考</font></p><p><a href="https://wangdoc.com/javascript/types/number.html">网道Javascript教程</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用苹果CMSv10搭建影视网站(超详细教程)</title>
    <link href="/posts/1cc5eeae.html"/>
    <url>/posts/1cc5eeae.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一台服务器</li><li><a href="http://www.maccms.cn/down.html">苹果CMSv10 版本源码</a><span id="more"></span><h2 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h2></li></ul><p><a href="https://www.bt.cn/bbs/thread-19376-1-1.html">安装教程见宝塔官网</a></p><p>安装完宝塔后，在软件商店里把运行环境安装了，网站运行环境有如下:</p><p>lamp 的全称是linux + apache + mysql +php<br>lnmp 的全称是linux + nginx + mysql + php </p><p>看个人喜好安装就行</p><p><img src="http://mark-imges.test.upcdn.net/images/lamp.png"></p><h2 id="安装苹果CMSv10系统"><a href="#安装苹果CMSv10系统" class="headerlink" title="安装苹果CMSv10系统"></a>安装苹果CMSv10系统</h2><ol><li><p>在宝塔中添加网站</p><p><img src="http://mark-imges.test.upcdn.net/images/cite.png"></p></li><li><p>将下载好的苹果cmsv10源码通过宝塔上传到服务器的www/wwwroot目录下并解压</p><img src="http://mark-imges.test.upcdn.net/images/yuanma.png" style="zoom:100%;" /></li><li><p>浏览器访问服务器ip或域名(域名必须已经绑定了ip后出现苹果cms安装界面,点开始安装</p><p><img src="http://mark-imges.test.upcdn.net/images/install.png"></p></li><li><p>若出现以下界面请到宝塔面板为该站点php安装fileinfo模块(如还不能解决请更换php版本)</p><p><img src="http://mark-imges.test.upcdn.net/images/sqlpeizhi.png"></p><p><img src="http://mark-imges.test.upcdn.net/images/changephp.png"></p></li><li><p>配置数据库信息</p><p><img src="http://mark-imges.test.upcdn.net/images/cmsset.png"></p></li><li><p>出现以下情况请到宝塔面板将该站点文件夹下的admin.php改名,并重新通过访问(ip/改名后的admin.php的文件名)进入cmsv10后台管理界面</p><p><img src="http://mark-imges.test.upcdn.net/images/adminset.png"></p></li><li><p>出现以下界面成功安装了cmsv10系统</p><p><img src="http://mark-imges.test.upcdn.net/images/success.png"></p></li></ol><h2 id="为cms系统配置采集站"><a href="#为cms系统配置采集站" class="headerlink" title="为cms系统配置采集站"></a>为cms系统配置采集站</h2><ol><li><p>百度电影采集站，并按该站点的帮助中心配置采集站</p><p><img src="http://mark-imges.test.upcdn.net/images/mac10.png"></p></li><li><p>这里以秒播采集站讲解，添加采集站接口先必须先添加对应的播放器,否则会出现无法播放的结果，操作完成后点击后台右上角[清缓存]，此时再看数据，已经可以正确的选择播放器并且可正常播放了</p><p><img src="http://mark-imges.test.upcdn.net/images/caiJi.png"></p></li><li><p>设置自动采集请参考采集站的帮助中心教程，讲的很详细，我就不多赘述了</p></li><li><p>其他的配置根据个人情况配置即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 中的浮动和清除浮动</title>
    <link href="/posts/bbeacaa3.html"/>
    <url>/posts/bbeacaa3.html</url>
    
    <content type="html"><![CDATA[<h2 id="浮动是什么"><a href="#浮动是什么" class="headerlink" title="浮动是什么"></a>浮动是什么</h2><p>浮动核心就一句话：<strong>浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素</strong>。请默念3次！</p><span id="more"></span><h2 id="浮动的特征"><a href="#浮动的特征" class="headerlink" title="浮动的特征"></a>浮动的特征</h2><ol><li><p>脱离文档流</p><ul><li>脱离文档，也就是说浮动不会影响普通元素的布局</li></ul></li><li><p>浮动可以内联排列</p><ul><li>浮动会向左/向右浮动，直到碰到另一个浮动元素为止，这是浮动可以内联排列的特征。也就是说，浮动可以设置宽高，并且能够一行多个，是介于<code>block</code>和<code>inline</code>之间的存在</li></ul></li><li><p>浮动会导致父元素高度坍塌</p><ul><li>浮动会脱离文档流，这个问题对整个页面布局有很大的影响。</li><li>浮动元素脱离文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没有了高度。</li></ul><h2 id="用clear清除浮动"><a href="#用clear清除浮动" class="headerlink" title="用clear清除浮动"></a>用clear清除浮动</h2><p>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。这句话，请默念5次！<br>要注意了，我们是通过在别的元素上清除浮动来实现撑开高度的， 而不是在浮动元素上。</p></li></ol><h3 id="使用带clear属性的空元素"><a href="#使用带clear属性的空元素" class="headerlink" title="使用带clear属性的空元素"></a>使用带clear属性的空元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">main</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid pink;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid green;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    //利用带<span class="hljs-attribute">clear</span>属性的空元素清除浮动</span><br><span class="language-css">    <span class="hljs-comment">/* .clear&#123;</span></span><br><span class="hljs-comment"><span class="language-css">        content: &quot;&quot;;</span></span><br><span class="hljs-comment"><span class="language-css">        clear: both;</span></span><br><span class="hljs-comment"><span class="language-css">    &#125; */</span></span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用CSS的-after伪元素"><a href="#使用CSS的-after伪元素" class="headerlink" title="使用CSS的:after伪元素"></a>使用CSS的:after伪元素</h3><p>结合<code>:after</code>伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。</p><p>需要注意的是为了IE6和IE7浏览器，要给main标签添加一条zoom:1;触发haslayout。(IE已经被微软抛弃了,妙呀)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">main</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid pink;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">4px</span> solid green;</span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-comment">/* 添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动 */</span></span><br><span class="language-css">    <span class="hljs-selector-tag">main</span><span class="hljs-selector-pseudo">:after</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">clear</span>: both;</span><br><span class="language-css">        <span class="hljs-attribute">visibility</span>: hidden;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">main</span>&#123;</span><br><span class="language-css">        <span class="hljs-comment">/* 触发haslayout */</span></span><br><span class="language-css">        zoom: <span class="hljs-number">1</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="BFC清除浮动"><a href="#BFC清除浮动" class="headerlink" title="BFC清除浮动"></a>BFC清除浮动</h2><p>BFC全称是块状格式化上下文，它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。<br>BFC的主要特征</p><ul><li>BFC就是页面上的一个独立的容器，容器内的子元素不会影响到外面的元素，外面的元素也不- -会影响到容器内的子元素。</li><li>盒子垂直方向的距离由margin决定，属于同一个BFC的相邻盒子的上下margin会发生折叠；分别触发两个元素的BFC，就可以解决垂直边距折叠的问题</li><li>BFC可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。<br>其中，BFC清除浮动就是用的“包含浮动”这条特性。</li></ul><h3 id="BFC的触发方式"><a href="#BFC的触发方式" class="headerlink" title="BFC的触发方式"></a>BFC的触发方式</h3><p>我们可以给父元素添加以下属性来触发BFC：</p><ol><li><code>float</code> 为 <code>left</code> | <code>right</code></li><li><code>overflow</code> 为 <code>hidden</code> | <code>auto</code> | <code>scorll</code></li><li><code>display</code> 为 <code>table-cell</code> | <code>table-caption</code> | <code>inline-block</code> | <code>flex</code> | <code>inline-flex</code></li><li><code>position</code> 为 <code>absolute</code> | <code>fixed</code></li></ol><p>清除浮动的方式有很多，我们只要根据不同的使用场景使用即可</p><p><u>文章参考来源:</u></p><p>[^1] <a href="https://juejin.im/post/582d98d5da2f600063e28f27"> <u>CSS清除浮动方法总结</u> </a></p><p>[^2] <a href="https://juejin.im/entry/580479b85bbb50005b7c5083"><u>CSS 中的浮动和清除浮动，梳理一下！</u></a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>let和var的区别</title>
    <link href="/posts/788c0b90.html"/>
    <url>/posts/788c0b90.html</url>
    
    <content type="html"><![CDATA[<h3 id="let不允许重复声明"><a href="#let不允许重复声明" class="headerlink" title="let不允许重复声明"></a>let不允许重复声明</h3><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">let</span> a=<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">let</span> a=<span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//ReferenceError</span><br>&#125;<br><br>&#123;<br>        <span class="hljs-keyword">var</span> b=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">var</span> b=<span class="hljs-number">4</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">//4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="let声明的变量只在let代码块有效"><a href="#let声明的变量只在let代码块有效" class="headerlink" title="let声明的变量只在let代码块有效"></a>let声明的变量只在let代码块有效</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>        <span class="hljs-keyword">let</span> a=<span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">var</span> b=<span class="hljs-number">10</span>;<br>&#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//a is not defined</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p><em>var声明变量是全局范围内有效的，虽然每次循环i都在改变，但是循环内都赋值给了a的i，相当于每次循环出来的i都是指向同一个i，也就是最后一个i，所以为10；</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=[];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        a[i]=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>            <br>        &#125;<br>  &#125;<br> a[<span class="hljs-number">6</span>]();<span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p><em>let声明的变量i只在本轮循环有效，每次循环的i都是一个全新的变量，所以值为6；</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=[];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        a[i]=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>            <br>        &#125;<br>    &#125;<br> a[<span class="hljs-number">6</span>]();<span class="hljs-comment">//6</span><br></code></pre></td></tr></table></figure><h3 id="var存在变量提升"><a href="#var存在变量提升" class="headerlink" title="var存在变量提升"></a>var存在变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//undifinded</span><br><span class="hljs-keyword">var</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-comment">//相当于</span><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>a=<span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">let</span>不存在变量提升<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<span class="hljs-comment">//ReferenceError</span><br><span class="hljs-keyword">let</span> b=<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>全局声明了变量tmp，但是在代码块中又用let声明了tmp，使得后者绑定了块级作用域，此时的tmp是在声明之前就赋值了，所以报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        tmp = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>        <span class="hljs-keyword">let</span> tmp;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp); <span class="hljs-comment">// ReferenceError</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        tmp = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>        <span class="hljs-keyword">var</span> tmp;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tmp); <span class="hljs-comment">// abc</span><br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式(Js)</title>
    <link href="/posts/ce934369.html"/>
    <url>/posts/ce934369.html</url>
    
    <content type="html"><![CDATA[<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是表示搜索模式的特殊字符串。也被称为<code>&quot;regex&quot;</code>,<code>&quot;regexp&quot;</code>它们可以帮助程序员匹配、搜索和替换文本。</p><span id="more"></span><h3 id="使用测试方法"><a href="#使用测试方法" class="headerlink" title="使用测试方法"></a>使用测试方法</h3><p>测试正则表达式的一种方法是使用<code>.test()</code>方法。<code>.test()</code>方法会把你编写的正则表达式应用到一个字符串（即括号内的内容），如果你的匹配模式成功匹配到字符，则返回<code>true</code>，反之，返回<code>false</code>。如果你想在字符串<code>&quot;Hello,World&quot;</code>中匹配到<code>&quot;Hello&quot;</code>，可以使用如下正则表达式：<code>/Hello/</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hi=<span class="hljs-string">&quot;Hello,World&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/Hello/</span>;<br>testRegex.<span class="hljs-title function_">test</span>(hi);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="同时用多种模式匹配文字字符串"><a href="#同时用多种模式匹配文字字符串" class="headerlink" title="同时用多种模式匹配文字字符串"></a>同时用多种模式匹配文字字符串</h3><p>你可以使用<code>|</code>操作符来匹配多个规则,例如，你可以使用<code>/are|lucky|dog/</code>在字符串<code>&quot;You are a lucky dog&quot;</code>中匹配到字符串<code>are,lucky,dog</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;You are a lucky dog&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/are|lucky|dog/</span>;<br>testRegex.<span class="hljs-title function_">test</span>(str);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="匹配时忽略大小写"><a href="#匹配时忽略大小写" class="headerlink" title="匹配时忽略大小写"></a>匹配时忽略大小写</h3><p>有时候，你可能也想匹配不同的英文字母大小写，这时我们可以在正则表达式<code>/</code>结尾加上忽略大小写标志<code>i</code>,如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello,world&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/Hello,WoRld/i</span>;<br>testRegex.<span class="hljs-title function_">test</span>(str)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="提取匹配项"><a href="#提取匹配项" class="headerlink" title="提取匹配项"></a>提取匹配项</h3><p>到目前为止，你只是检查了一个匹配模式是否存在于字符串中。你还可以使用<code>.match()</code>方法来提取你找到的实际匹配项。请使用字符串来调用<code>.match()</code>方法，并在括号内传入正则表达式。以下是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello,world&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-string">&quot;hello&quot;</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//return [&quot;hello&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>到目前为止，你只能提取或搜寻一次匹配模式。若要多次搜寻或提取匹配模式，你可以使用<code>g</code>标志。以下是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello,hello,hello&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/hello/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;hello&quot;,&quot;hello&quot;,&quot;hello&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="用通配符-匹配任何内容"><a href="#用通配符-匹配任何内容" class="headerlink" title="用通配符.匹配任何内容"></a>用通配符.匹配任何内容</h3><p>通配符<code>.</code>将匹配任何一个字符。通配符也叫<code>dot</code>或<code>period</code>。你可以像使用正则表达式中任何其他字符一样使用通配符。例如，如果你想匹配<code>&quot;hug&quot;</code>、<code>&quot;huh&quot;</code>、<code>&quot;hut&quot;</code>和<code>&quot;hum&quot;</code>，你可以使用正则表达式<code>/hu./</code>匹配以上四个单词。以下是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;aaa,aab,aac,aad&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/aa./g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;aaa&quot;,&quot;aab&quot;,&quot;aac&quot;,&quot;aad&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="将单个字符与多种可能性匹配"><a href="#将单个字符与多种可能性匹配" class="headerlink" title="将单个字符与多种可能性匹配"></a>将单个字符与多种可能性匹配</h3><p>你可以使用<code>字符集</code>搜寻具有一定灵活性的文字匹配模式。字符集允许你通过把它们放在方括号（<code>[</code>和<code>]</code>）之间的方式来定义一组你需要匹配的字符串。例如，你想要匹配<code>&quot;bag&quot;</code>、<code>&quot;big&quot;</code>和<code>&quot;bug&quot;</code>，但是不想匹配<code>&quot;bog&quot;</code>。你可以创建正则表达式<code>/b[aiu]g/</code>来执行此操作。<code>[aiu]</code>是只匹配字符<code>&quot;a&quot;</code>、<code>&quot;i&quot;</code>或者<code>&quot;u&quot;</code>的字符集。以下是示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;bag,big,bug&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/b[aiu]g/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;bag&quot;,&quot;big&quot;,&quot;bug&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配字母表中的字母"><a href="#匹配字母表中的字母" class="headerlink" title="匹配字母表中的字母"></a>匹配字母表中的字母</h3><p>在<code>字符集</code>中，你可以使用<code>连字符</code>（<code>-</code>）来定义要匹配的字符范围。例如，要匹配小写字母<code>a</code>到<code>e</code>，你可以使用<code>[a-e]</code>。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;cat,bat,mat&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/[b-m]at/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;bat&quot;,&quot;cat&quot;,&quot;mat&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配字母表中的数字和字母"><a href="#匹配字母表中的数字和字母" class="headerlink" title="匹配字母表中的数字和字母"></a>匹配字母表中的数字和字母</h3><p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。它还可以匹配一系列数字。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Hello,2020&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/[hello0-2]/gi</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;2&quot;, &quot;0&quot;, &quot;2&quot;, &quot;0&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配单个未指定的字符"><a href="#匹配单个未指定的字符" class="headerlink" title="匹配单个未指定的字符"></a>匹配单个未指定的字符</h3><p>到目前为止，你已创建了一个你想要匹配的字符集合，但你也可以创建一个你不想匹配的字符集合。这些类型的字符集称为<code>否定字符集</code>。</p><p>要创建<code>否定字符集</code>，你需要在开始括号后面和不想匹配的字符前面放置<code>插入字符</code>（即<code>^</code>）。</p><p>例如，<code>/[^aeiou]/gi</code>匹配所有非元音字符。注意，字符<code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code>和空白字符等也会被匹配，该否定字符集仅排除元音字符。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;abcdefg&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/[^a-c]/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h3><p>有时，你需要匹配出现一次或者连续多次的的字符（或字符组）。你可以使用<code>+</code>符号来检查情况是否如此。记住，字符或匹配模式必须一个接一个地连续出现。</p><p>例如，<code>/a+/g</code>会在<code>&quot;abc&quot;</code>中匹配到一个匹配项，并且返回<code>[&quot;a&quot;]</code>。因为<code>+</code>的存在，它也会在<code>&quot;aabc&quot;</code>中匹配到一个匹配项，然后返回<code>[&quot;aa&quot;]</code>。</p><p>如果它是检查字符串<code>&quot;abab&quot;</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。最后，因为在字符串<code>&quot;bcd&quot;</code>中没有<code>&quot;a&quot;</code>，因此找不到匹配项。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;abaabaaabbba&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/a+/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h3><p>上一次的挑战中使用了加号<code>+</code>来查找出现一次或多次的字符。还有一个选项可以匹配出现零次或多次的字符。</p><p>执行该操作的字符叫做<code>asterisk</code>或<code>star</code>，即<code>*</code>。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;haaaaaaaa&quot;</span>;<br><span class="hljs-keyword">let</span> str1=<span class="hljs-string">&quot;hgggggggg&quot;</span>;<br><span class="hljs-keyword">let</span> textRegex=<span class="hljs-regexp">/ha*/</span>;<br>str.<span class="hljs-title function_">match</span>(textRegex);<span class="hljs-comment">//Return [&quot;haaaaaaaa&quot;]</span><br>str1.<span class="hljs-title function_">match</span>(textRegex);<span class="hljs-comment">//Return [&quot;h&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h3><p>在正则表达式中，<code>贪婪</code>匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。另一种方案称为<code>懒惰</code>匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p><p>你可以将正则表达式<code>/t[a-z]*i/</code>应用于字符串<code>&quot;titanic&quot;</code>。这个正则表达式是一个以<code>t</code>开始，以<code>i</code>结束，并且中间有一些字母的匹配模式。</p><p>正则表达式默认是<code>贪婪</code>匹配，因此匹配返回为<code>[&quot;titani&quot;]</code>。它会匹配到适合该匹配模式的最大子字符串。</p><p>但是，你可以使用<code>?</code>字符来将其变成<code>懒惰</code>匹配。调整后的正则表达式<code>/t[a-z]*?i/</code>匹配字符串<code>&quot;titanic&quot;</code>返回<code>[&quot;ti&quot;]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;different&quot;</span>;<br><span class="hljs-keyword">let</span> textRegex=<span class="hljs-regexp">/d[a-z]*e/</span>;<br><span class="hljs-keyword">let</span> textRegex1=<span class="hljs-regexp">/d[a-z]*?e/</span>;<br>str.<span class="hljs-title function_">match</span>(textRegex);<span class="hljs-comment">//Return [&quot;differe&quot;]</span><br>str.<span class="hljs-title function_">match</span>(textRegex1);<span class="hljs-comment">//Return [&quot;diffe&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="在狩猎中找到一个或多个罪犯"><a href="#在狩猎中找到一个或多个罪犯" class="headerlink" title="在狩猎中找到一个或多个罪犯"></a>在狩猎中找到一个或多个罪犯</h3><p>群罪犯逃出监狱逃跑，但你不知道有多少人。但是，你知道他们和其他人在一起时会保持紧密联系。你有责任立刻找到所有的罪犯。</p><p>这里有一个示例来回顾如何做到这一点：</p><p>当字母<code>z</code>在一行中出现一次或连续多次时，正则表达式<code>/z+/</code>会匹配到它。它会在以下所有字符串中找到匹配项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;z&quot;</span><br><span class="hljs-string">&quot;zzzzzz&quot;</span><br><span class="hljs-string">&quot;ABCzzzz&quot;</span><br><span class="hljs-string">&quot;zzzzABC&quot;</span><br><span class="hljs-string">&quot;abczzzzzzzzzzzzzzzzzzzzzabc&quot;</span><br></code></pre></td></tr></table></figure><p>但是它不会在以下字符串中找到匹配项，因为它们中没有字母<code>z</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&quot;ABC&quot;</span><br><span class="hljs-string">&quot;abcabc&quot;</span><br></code></pre></td></tr></table></figure><p>编写一个<code>贪婪</code>正则表达式，在一组其他人中匹配到一个或多个罪犯。罪犯由大写字母<code>C</code>表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// example crowd gathering</span><br><span class="hljs-keyword">let</span> crowd = <span class="hljs-string">&#x27;P1P2P3P4P5P6CCCP7P8P9&#x27;</span>;<br><br><span class="hljs-keyword">let</span> reCriminals = <span class="hljs-regexp">/./</span>; <span class="hljs-comment">// 修改这一行</span><br><br><span class="hljs-keyword">let</span> matchedCriminals = crowd.<span class="hljs-title function_">match</span>(reCriminals);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchedCriminals);<br></code></pre></td></tr></table></figure><p>示例答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// example crowd gathering</span><br><span class="hljs-keyword">let</span> crowd = <span class="hljs-string">&#x27;P1P2P3P4P5P6CCCP7P8P9&#x27;</span>;<br><br><span class="hljs-keyword">let</span> reCriminals = <span class="hljs-regexp">/C+/</span>; <span class="hljs-comment">// 修改这一行</span><br><br><span class="hljs-keyword">let</span> matchedCriminals = crowd.<span class="hljs-title function_">match</span>(reCriminals);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchedCriminals);<br></code></pre></td></tr></table></figure><h3 id="匹配字符串的开头"><a href="#匹配字符串的开头" class="headerlink" title="匹配字符串的开头"></a>匹配字符串的开头</h3><p>你使用<code>字符集</code>中的<code>插入</code>符号（<code>^</code>）来创建一个<code>否定字符集</code>，形如<code>[^thingsThatWillNotBeMatched]</code>。在<code>字符集</code>之外，插入<code>^</code>符号用于字符串的开头搜寻匹配模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Hello,World&quot;</span>;<br><span class="hljs-keyword">let</span> textRegex=<span class="hljs-regexp">/^Hello/</span>;<br><span class="hljs-keyword">let</span> textRegex1=<span class="hljs-regexp">/^World/</span>;<br>textRegex.<span class="hljs-title function_">test</span>(str);<span class="hljs-comment">//true</span><br>textRegex1.<span class="hljs-title function_">test</span>(str);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="匹配字符串的末尾"><a href="#匹配字符串的末尾" class="headerlink" title="匹配字符串的末尾"></a>匹配字符串的末尾</h3><p>你可以使用正则表达式的<code>美元</code>符号<code>$</code>来搜寻字符串的结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello,world&quot;</span>;<br><span class="hljs-keyword">let</span> str1=<span class="hljs-string">&quot;wold,hello&quot;</span>;<br><span class="hljs-keyword">let</span> textRegex=<span class="hljs-regexp">/world$/</span>;<br>textRegex.<span class="hljs-title function_">test</span>(str);<span class="hljs-comment">//true</span><br>textRegex.<span class="hljs-title function_">test</span>(str1);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h3><p>使用字符类，你可以使用<code>[a-z]</code>搜寻字母表中的所有字母。这种字符类是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p><p>JavaScript 中与字母表匹配的最接近的字符类是<code>\w</code>，这个缩写等同于<code>[A-Za-z0-9_]</code>。它不仅可以匹配大小写字母和数字，注意，它还会匹配下划线字符（<code>_</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;Hello_World2020&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\w+/</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;Hello_World2020&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h3><p>你可以使用<code>\W</code>搜寻和<code>\w</code>相反的匹配模式。注意，相反匹配模式使用大写字母。此缩写与<code>[^A-Za-z0-9_]</code>是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello,World!&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\W/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;,&quot;,&quot;!&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有数字"><a href="#匹配所有数字" class="headerlink" title="匹配所有数字"></a>匹配所有数字</h3><p>查找数字字符的缩写是<code>\d</code>，注意是小写的<code>d</code>。这等同于字符类<code>[0-9]</code>，它查找 0 到 9 之间任意数字的单个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;0123hello&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\d/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h3><p>查找非数字字符的缩写是<code>\D</code>。这等同于字符串<code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello2020world&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\D/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="限制可能的用户名"><a href="#限制可能的用户名" class="headerlink" title="限制可能的用户名"></a>限制可能的用户名</h3><p>你需要检查数据库中的所有用户名。以下是用户在创建用户名时必须遵守的一些简单规则。</p><ol><li><p>用户名中的数字必须在最后，且数字可以有零个或多个。</p></li><li><p>用户名字母可以是小写字母和大写字母。</p></li><li><p>用户名长度必须至少为两个字符。两位用户名只能使用字母。</p></li></ol><p>修改正则表达式<code>userCheck</code>以适合上面列出的约束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span>;<br><span class="hljs-keyword">let</span> userCheck = <span class="hljs-regexp">/change/</span>; <span class="hljs-comment">// 修改这一行</span><br><span class="hljs-keyword">let</span> result = userCheck.<span class="hljs-title function_">test</span>(username);<br></code></pre></td></tr></table></figure><p>示例答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span>;<br><span class="hljs-keyword">let</span> username1 = <span class="hljs-string">&quot;Mike666&quot;</span>;<br><span class="hljs-keyword">let</span> username2 = <span class="hljs-string">&quot;KK&quot;</span>;<br><span class="hljs-keyword">let</span> userCheck = <span class="hljs-regexp">/^[a-z]([0-9][0-9]+|[a-z]+[\d]*)$/i</span>; <span class="hljs-comment">// 修改这一行</span><br>userCheck.<span class="hljs-title function_">test</span>(username);<span class="hljs-comment">//false</span><br>userCheck.<span class="hljs-title function_">test</span>(username1);<span class="hljs-comment">//true</span><br>userCheck.<span class="hljs-title function_">test</span>(username2);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>你可以使用<code>\s</code>搜寻空格，其中<code>s</code>是小写。此匹配模式不仅匹配空格，还匹配回车符、制表符、换页符和换行符，你可以将其视为与<code>[\r\t\f\n\v]</code>类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;hello hello hello &quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\s/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return  [&quot; &quot;, &quot; &quot;, &quot; &quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配非空白字符"><a href="#匹配非空白字符" class="headerlink" title="匹配非空白字符"></a>匹配非空白字符</h3><p>使用<code>\S</code>搜寻非空白字符，其中<code>S</code>是大写。此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。你可以认为这类似于字符类<code>[^\r\t\f\n\v]</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;h h h h h&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/\S/g</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;h&quot;, &quot;h&quot;, &quot;h&quot;, &quot;h&quot;, &quot;h&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h3><p>你使用加号<code>+</code>查找一个或多个字符，使用星号<code>*</code>查找零个或多个字符。这些都很方便，但有时你需要匹配一定范围的匹配模式。</p><p>你可以使用<code>数量说明符</code>指定匹配模式的上下限。数量说明符与花括号（<code>&#123;</code>和<code>&#125;</code>）一起使用。你可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;haaakk&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/ha&#123;1,3&#125;/</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex));<span class="hljs-comment">//Return [&quot;haaa&quot;]</span><br>str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/ha&#123;1,2&#125;/</span>);<span class="hljs-comment">//Return [&quot;haa&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="只指定匹配的下限"><a href="#只指定匹配的下限" class="headerlink" title="只指定匹配的下限"></a>只指定匹配的下限</h3><p>你可以使用带有花括号的<code>数量说明符</code>来指定匹配模式的上下限。但有时候你只想指定匹配模式的下限而不需要指定上限。</p><p>为此，在第一个数字后面跟一个逗号即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;haaaaa&quot;</span>;<br><span class="hljs-keyword">let</span> str1=<span class="hljs-string">&quot;haaaaaaaa&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/ha&#123;3,&#125;/</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;haaaaa&quot;]</span><br>str1.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;haaaaaaaa&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h3><p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str=<span class="hljs-string">&quot;helllllllo&quot;</span>;<br><span class="hljs-keyword">let</span> testRegex=<span class="hljs-regexp">/hel&#123;3&#125;/</span>;<br>str.<span class="hljs-title function_">match</span>(testRegex);<span class="hljs-comment">//Return [&quot;helll&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h3><p>有时，你想要搜寻的匹配模式可能有不确定是否存在的部分。尽管如此，你还是想检查它们。</p><p>为此，你可以使用问号<code>?</code>指定可能存在的元素。这将检查前面的零个或一个元素。你可以将此符号视为前面的元素是可选的</p><p>例如，美式英语和英式英语略有不同，你可以使用问号来匹配两种拼写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> american = <span class="hljs-string">&quot;color&quot;</span>;<br><span class="hljs-keyword">let</span> british = <span class="hljs-string">&quot;colour&quot;</span>;<br><span class="hljs-keyword">let</span> rainbowRegex= <span class="hljs-regexp">/colou?r/</span>;<br>rainbowRegex.<span class="hljs-title function_">test</span>(american); <span class="hljs-comment">// Returns true</span><br>rainbowRegex.<span class="hljs-title function_">test</span>(british); <span class="hljs-comment">// Returns true</span><br></code></pre></td></tr></table></figure><h3 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h3><p><code>先行断言</code>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p><p>有两种<code>先行断言</code>：<code>正向先行断言</code>和<code>负向先行断言</code>。</p><p><code>正向先行断言</code>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分。</p><p>另一方面，<code>负向先行断言</code>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> quit = <span class="hljs-string">&quot;qu&quot;</span>;<br><span class="hljs-keyword">let</span> noquit = <span class="hljs-string">&quot;qt&quot;</span>;<br><span class="hljs-keyword">let</span> quRegex= <span class="hljs-regexp">/q(?=u)/</span>;<br><span class="hljs-keyword">let</span> qRegex = <span class="hljs-regexp">/q(?!u)/</span>;<br>quit.<span class="hljs-title function_">match</span>(quRegex); <span class="hljs-comment">// Returns [&quot;q&quot;]</span><br>noquit.<span class="hljs-title function_">match</span>(qRegex); <span class="hljs-comment">// Returns [&quot;q&quot;]</span><br></code></pre></td></tr></table></figure><p><code>先行断言</code>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> password = <span class="hljs-string">&quot;abc123&quot;</span>;<br><span class="hljs-keyword">let</span> checkPass = <span class="hljs-regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span>;<br>checkPass.<span class="hljs-title function_">test</span>(password); <span class="hljs-comment">// Returns true</span><br></code></pre></td></tr></table></figure><h3 id="使用捕获组重用模式"><a href="#使用捕获组重用模式" class="headerlink" title="使用捕获组重用模式"></a>使用捕获组重用模式</h3><p>一些你所搜寻的匹配模式会在字符串中出现多次，手动重复该正则表达式太浪费了。有一种更好的方法可以指定何时在字符串中会有多个重复的子字符串。</p><p>你可以使用<code>捕获组</code>搜寻重复的子字符串。括号<code>(</code>和<code>)</code>可以用来匹配重复的子字符串。你只需要把重复匹配模式的正则表达式放在括号中即可。</p><p>要指定重复字符串将出现的位置，可以使用反斜杠（<code>\</code>）后接一个数字。这个数字从 1 开始，随着你使用的每个捕获组的增加而增加。这里有一个示例，<code>\1</code>可以匹配第一个组。</p><p>下面的示例匹配任意两个被空格分割的单词：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> repeatStr = <span class="hljs-string">&quot;regex regex&quot;</span>;<br><span class="hljs-keyword">let</span> repeatRegex = <span class="hljs-regexp">/(\w+)\s\1/</span>;<br>repeatRegex.<span class="hljs-title function_">test</span>(repeatStr); <span class="hljs-comment">// Returns true</span><br>repeatStr.<span class="hljs-title function_">match</span>(repeatRegex); <span class="hljs-comment">// Returns [&quot;regex regex&quot;, &quot;regex&quot;]</span><br></code></pre></td></tr></table></figure><p>在字符串上使用<code>.match()</code>方法将返回一个数组，其中包含它匹配的字符串及其捕获组</p><h3 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h3><p>搜索功能是很有用的。但是，当你的搜索也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p><p>可以使用字符串上<code>.replace()</code>方法来搜索并替换字符串中的文本。<code>.replace()</code>的输入首先是你想要搜索的正则表达式匹配模式，第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> wrongText = <span class="hljs-string">&quot;The sky is silver.&quot;</span>;<br><span class="hljs-keyword">let</span> silverRegex = <span class="hljs-regexp">/silver/</span>;<br>wrongText.<span class="hljs-title function_">replace</span>(silverRegex, <span class="hljs-string">&quot;blue&quot;</span>);<br><span class="hljs-comment">// Returns &quot;The sky is blue.&quot;</span><br></code></pre></td></tr></table></figure><p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Code Camp&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\w+)\s(\w+)/</span>, <span class="hljs-string">&#x27;$2 $1&#x27;</span>);<br><span class="hljs-comment">// Returns &quot;Camp Code&quot;</span><br></code></pre></td></tr></table></figure><h3 id="删除开头和结尾的空白"><a href="#删除开头和结尾的空白" class="headerlink" title="删除开头和结尾的空白"></a>删除开头和结尾的空白</h3><p>编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;   Hello, World!  &quot;</span>;<br><span class="hljs-keyword">let</span> wsRegex = <span class="hljs-regexp">/^\s+|\s+$/g</span>; <br><span class="hljs-keyword">let</span> result = hello.<span class="hljs-title function_">replace</span>(wsRegex, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建站知识一</title>
    <link href="/posts/d3aa53cc.html"/>
    <url>/posts/d3aa53cc.html</url>
    
    <content type="html"><![CDATA[<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p><strong>域名</strong>（英语：<strong>Domain Name</strong>），又称<strong>网域</strong>，是由一串用点分隔的名字组成的<a href="https://baike.baidu.com/item/Internet">Internet</a>上某一台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。</p><span id="more"></span><p>域名就相当于一个家庭的门牌号码，别人通过这个号码可以很容易的找到你。我们可以通过各种域名服务商购买自己需要的域名，并进行实名认证和<a href="https://baike.baidu.com/item/%E5%A4%87%E6%A1%88/5130430?fr=aladdin#6">备案</a>。如果是国外服务器，可以免备案。</p><p>域名存在的原因：由于<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80/150859">IP地址</a>具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过网域名称系统（<a href="https://baike.baidu.com/item/DNS">DNS</a>，Domain Name System）来将域名和<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>相互<a href="https://baike.baidu.com/item/%E6%98%A0%E5%B0%84/20402621">映射</a>，使人更方便地访问<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>，而不用去记住能够被机器直接读取的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>数串。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>网站是在互联网上拥有<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062">域名</a>或<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80/8715107">地址</a>并提供一定<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1/9498645">网络服务</a>的主机，是存储文件的空间，以<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>为载体。人们可通过<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8/213911">浏览器</a>等进行访问、查找文件，也可通过<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/22034498">远程文件传输</a>(<a href="https://baike.baidu.com/item/FTP/13839">FTP</a>)方式上传、下载网站文件。</p><p>你或别人都可以通过dns域名解析访问你的网站，而当他们通过域名进入你的网站后，所呈现的内容就是你储存在网站上的部分内容。</p><p>而我们网站上的内容则储存在空间中，常见网站空间：<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA">虚拟主机</a>，<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4">虚拟空间</a>，独立服务器，<a href="https://baike.baidu.com/item/%E4%BA%91%E4%B8%BB%E6%9C%BA">云主机</a>，<a href="https://baike.baidu.com/item/VPS">VPS</a>，等等。我们可以通过像腾讯云，阿里云这样的服务器供应商购买我们的服务器主机。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D">域名</a>解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。</p><p>域名解析就是域名到IP地址的转换过程。域名的解析工作由<a href="https://baike.baidu.com/item/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8">DNS服务器</a>完成。域名购买服务商一般都会提供域名解析服务。</p><p>通过域名解析服务，我们可以通过我们的域名访问到我们购买的服务器空间，而解析服务简单来说就是把你域名和服务器ip或另一个域名进行绑定，从而进行对服务器的访问。当然，你也可以直接通过ip访问你的服务器。</p>]]></content>
    
    
    <categories>
      
      <category>Web知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
